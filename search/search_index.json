{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#sierra","title":"Sierra","text":"<p>When it comes to investigations\u2014OSINT, pentesting, journalism, or data analysis\u2014the devil is in the details. Those details are often buried in cumbersome tools and scattered notes. Sierra is your all\u2011in\u2011one investigative dashboard, bringing clarity, automation, and intelligence into a single interface.</p>"},{"location":"#why-sierra","title":"Why Sierra?","text":""},{"location":"#efficient-note-management","title":"\ud83d\udd16 Efficient Note Management","text":"<ul> <li>Write notes and define relationships in Markdown.</li> <li>Visualize your investigation as a dynamic graph for quick reference.</li> </ul>"},{"location":"#customization","title":"\ud83c\udfa8 Customization","text":"<ul> <li>Assign colors, icons, and labels to different entities.</li> <li>Export high\u2011resolution graphs for sharing or reporting.</li> </ul>"},{"location":"#automation","title":"\u2699\ufe0f Automation","text":"<ul> <li>Integrate and run your existing tools (Python, Bash, PowerShell, etc.) with Invoker scripts.</li> <li>Configure workflows in simple YAML, then execute them inside Sierra.</li> <li>Focus on analysis\u2014not busywork.</li> </ul>"},{"location":"#ai-advisor","title":"\ud83e\udd16 AI Advisor","text":"<p>Your AI\u2011powered Case Advisor helps you:</p> <ol> <li>Summarize existing information on targets</li> <li>Highlight actionable leads you might miss</li> <li>Deduce new insights from your data    Generate optimized prompts for ChatGPT, Bard, or any LLM with one click.</li> </ol>"},{"location":"#practical-solutions","title":"Practical Solutions","text":"The Problem The Sierra Solution Details hidden in disparate tools and notes Unified Markdown + graph view for instant context Manual switching between tools wastes time One\u2011click Invoker scripts automate your workflows Reports lack polish and clarity High\u2011res exports and structured summaries"},{"location":"#use-cases","title":"Use Cases","text":"<ul> <li>OSINT: Pattern analysis &amp; public data mapping</li> <li>Pentesting: Network visualization &amp; vulnerability tracking</li> <li>Intelligence: Correlate multi\u2011source data relationships</li> <li>Journalism: Organize leads, timelines, and interviews</li> </ul>"},{"location":"#download","title":"Download","text":"<p>Hobbyist Edition \u2014 FREE, no limits Download Sierra</p> <p>Terms of Service \u00b7 Privacy Policy</p>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#configuration","title":"\u2699\ufe0f Configuration","text":"<p>Configure the SierraDevelopmentClient to get the most out of Sierra\u2019s structured development workflow. This guide covers best practices around logging, caching, and environment layout.</p>"},{"location":"configuration/#client-construction","title":"\ud83e\uddf1 Client Construction","text":"<p>At the core of every workflow is the <code>SierraDevelopmentClient</code>. You can instantiate it with custom logging, caching, and environment parameters.</p>"},{"location":"configuration/#recommended-client-setup","title":"\u2705 Recommended Client Setup","text":"Python<pre><code>import sierra\nimport pathlib\nfrom sierra.internal.logger import LogLevel, UniversalLogger\n\n# Create the logger\nlogger = UniversalLogger(\n    name=\"Sierra\",\n    level=LogLevel.DEBUG,  # DEBUG or INFO for dev environments\n)\n\n# Build the client\nclient = sierra.SierraDevelopmentClient(\n    environment_path=pathlib.Path.cwd(),       # Base directory for scripts/config\n    environment_name=\"default_env\",                    # Logical name for this dev env\n    logger=logger,                             # Custom logger\n    # Optional: pass `cache=...` if needed\n)\n</code></pre> <p>This initializes:</p> <ul> <li>Environment paths and config files</li> <li>Logger with debug-level tracing</li> <li>HTTP client (e.g. for plugins or services)</li> <li>Script sideloader</li> <li>Compiler + Builder pipeline</li> </ul>"},{"location":"configuration/#project-layout","title":"\ud83d\udcc1 Project Layout","text":"<p>Here\u2019s the standard folder structure Sierra expects:</p> Text Only<pre><code>default_env/\n\u251c\u2500\u2500 scripts/              \u2190 Your invoker source files\n\u2502   \u251c\u2500\u2500 greet.py\n\u2502   \u2514\u2500\u2500 notify.py\n\u251c\u2500\u2500 invokers/             \u2190 Auto\u2011compiled standalone invokers\n\u251c\u2500\u2500 config.yaml           \u2190 Auto\u2011generated CLI config\n\u251c\u2500\u2500 cache/                \u2190 (optional) Persistent build cache\n\u251c\u2500\u2500 compile.py            \u2190 Client bootstrap / entry script\n\u2514\u2500\u2500 README.md\n</code></pre> <p>You can change the base path with <code>environment_path</code>, but <code>scripts/</code> must exist inside it.</p>"},{"location":"configuration/#logging-best-practices","title":"\ud83e\udde0 Logging Best Practices","text":"<p>Use <code>UniversalLogger</code> to trace build, validation, or runtime errors.</p>"},{"location":"configuration/#available-log-levels","title":"Available Log Levels","text":"Level Description <code>DEBUG</code> Most verbose \u2014 useful during development <code>INFO</code> Normal output \u2014 good for regular builds <code>WARNING</code> Misconfiguration or redundancy <code>ERROR</code> Exceptions or halting errors <p>Set level during logger construction:</p> Python<pre><code>UniversalLogger(name=\"Sierra\", level=LogLevel.INFO)\n</code></pre> <p>Sierra uses structured messages for every phase:</p> <ul> <li>Environment init</li> <li>Sideloader source population</li> <li>Script discovery</li> <li>Invoker registration</li> <li>Compiler stages</li> </ul>"},{"location":"configuration/#caching-optional","title":"\ud83d\udcbe Caching (Optional)","text":"<p>You can pass a <code>CacheManager</code> instance to control how Sierra handles repeated compilation, YAML regeneration, and data reuse:</p> Python<pre><code>from sierra.internal.cache import CacheManager\n\nclient = sierra.SierraDevelopmentClient(\n    cache=CacheManager(cache_dir=pathlib.Path(\"default_env/cache\"))\n)\n</code></pre> <p>By default, caching is enabled unless disabled explicitly.</p>"},{"location":"configuration/#script-autodiscovery","title":"\ud83d\udd0e Script Auto\u2011Discovery","text":"<p>Call this in your entry script to load all <code>InvokerScript</code> instances from <code>scripts/</code>:</p> Python<pre><code>client.load_invokers_from_scripts()\n</code></pre> <p>Each script must expose a <code>load()</code> function like this:</p> Python<pre><code>def load(client: sierra.SierraDevelopmentClient) -&gt; None:\n    client.load_invoker(invoker)\n</code></pre> <p>Sierra uses Python\u2019s <code>importlib</code> to dynamically load and validate each invoker module.</p>"},{"location":"configuration/#environment-name","title":"\ud83e\uddf1 Environment Name","text":"<p>The <code>environment_name</code> is used for logical grouping. You can create multiple environments (e.g., <code>default_env</code>, <code>prod</code>, <code>test</code>) and Sierra will handle separate script and build trees per environment.</p> <p>This affects:</p> <ul> <li>Generated YAML config name</li> <li>Build paths</li> <li>Contextual logging</li> </ul>"},{"location":"configuration/#full-example","title":"\ud83e\uddea Full Example","text":"Python<pre><code>import sierra\nfrom sierra.internal.logger import UniversalLogger, LogLevel\n\nclient = sierra.SierraDevelopmentClient(\n    environment_path=\"default_env\",\n    environment_name=\"default_env\",\n    logger=UniversalLogger(name=\"Sierra\", level=LogLevel.DEBUG),\n)\n\nclient.load_invokers_from_scripts()\nclient.compiler.compile()\n</code></pre>"},{"location":"configuration/#summary","title":"\ud83e\uddf5 Summary","text":"Config Field Purpose Default <code>environment_path</code> Base path for scripts &amp; builds <code>Path.cwd()</code> <code>environment_name</code> Logical name for config/environment <code>\"default_env\"</code> <code>logger</code> Structured logging output Built\u2011in <code>UniversalLogger</code> <code>cache</code> Optional caching backend Enabled by default <code>http_client</code> Internal HTTP client (optional use) <code>httpx.Client</code>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"\u2699\ufe0f Installation","text":""},{"location":"installation/#pypi","title":"\ud83d\udce6 PyPI","text":"<p>Install from PyPI:</p> pip install sierra-dev"},{"location":"installation/#from-source","title":"\ud83d\udee0\ufe0f From Source","text":"git clone https://github.com/xsyncio/sierra-dev.gitcd sierra-devpip install ."},{"location":"installation/#usage-examples","title":"\ud83d\udd27 Usage Examples","text":""},{"location":"installation/#1-building-an-invoker-script","title":"1. Building an Invoker Script","text":"Python<pre><code>import sierra\nimport requests\n# Define an InvokerScript\ninvoker = sierra.InvokerScript(\n    name=\"greet\",\n    description=\"Prints a personalized greeting message.\"\n)\n\ninvoker.requirement([\"requests\"])\n\n# Dependency functions\n@invoker.dependency\ndef random_function_one(param: int) -&gt; int:\n    return param * 2\n\n@invoker.dependency\ndef random_function_two(message: str) -&gt; str:\n    return message.upper()\n\n# Entry point\n@invoker.entry_point\ndef run(\n    name: sierra.Param[\n        str | None,\n        sierra.SierraOption(description=\"Name of the person to greet.\", mandatory=\"MANDATORY\")\n    ],\n    polite: sierra.Param[\n        bool | None,\n        sierra.SierraOption(description=\"Include polite greeting?\", mandatory=None)\n    ] = False\n) -&gt; None:\n    if name is None:\n        result = sierra.create_error_result(\"Missing mandatory parameter: name\")\n    else:\n        greeting = f\"Hello, {name}!\"\n        if polite:\n            greeting = f\"Good day to you, {name}!\"\n        result = sierra.create_tree_result([greeting])\n    print(result)\n\n# Loader function\ndef load(client: sierra.SierraDevelopmentClient) -&gt; None:\n    client.load_invoker(invoker)\n</code></pre>"},{"location":"installation/#2-compiling-running","title":"2. Compiling &amp; Running","text":"Python<pre><code>import sierra\n\n# Initialize the Sierra development client\nclient = sierra.SierraDevelopmentClient(\n    environment_name=\"default_env\",\n    logger=sierra.UniversalLogger(\n        name=\"Sierra\",\n        level=sierra.sierra_internal_logger.LogLevel.DEBUG\n    ),\n)\n\n# Discover and register invokers\nclient.load_invokers_from_scripts()\n\n# Compile all invoker scripts and generate config.yaml\nclient.compiler.compile()\n</code></pre>"},{"location":"installation/#api-highlights","title":"\ud83d\udce6 API Highlights","text":"<ul> <li><code>sierra.core.builder</code>: Build invoker scripts programmatically</li> <li><code>sierra.core.compiler</code>: Compile and package scripts</li> <li><code>sierra.core.loader</code>: Load compiled scripts into the runtime</li> <li><code>sierra.invoker</code>: Define script actions, dependencies, and parameters</li> <li><code>sierra.options</code>: Parameter and option definitions</li> <li><code>sierra.SierraDevelopmentClient</code>: High-level orchestration client</li> </ul>"},{"location":"installation/#configuration-extensibility","title":"\ud83d\udee0\ufe0f Configuration &amp; Extensibility","text":"<ul> <li>Configuration File: Customize paths, logging, and plugins via <code>sierra.config.yaml</code></li> <li>Plugin Directory: Drop custom plugins into the <code>plugins/</code> folder</li> <li>Abstract Base Classes: Implement new Sierra components by extending <code>sierra.abc.sierra</code></li> </ul>"},{"location":"installation/#contributing-code-of-conduct","title":"\ud83d\udca1 Contributing &amp; Code of Conduct","text":"<p>We welcome contributions! Please review CONTRIBUTING.md and adhere to the Python Code of Conduct.</p>"},{"location":"installation/#license-authors","title":"\ud83d\udcdd License &amp; Authors","text":"<p>sierra-dev is released under the GNU Affero General Public License.</p> <p>Authors:</p> <ul> <li>Xsyncio</li> </ul>"},{"location":"invoker/","title":"Invoker","text":""},{"location":"invoker/#sierra-invoker","title":"SIERRA Invoker","text":"<p>This document walks you through creating custom Invoker scripts to extend SIERRA\u2019s functionality and automate tasks in your investigations.</p>"},{"location":"invoker/#1-overview","title":"1. Overview","text":"<p>Invoker scripts in SIERRA allow you to integrate external tools and scripts (Python, Bash, PowerShell, etc.) into the SIERRA interface. You define each script with a simple YAML configuration file that describes:</p> <ul> <li>Where to find your script files (<code>PATHS</code>)</li> <li>Which scripts to load (<code>SCRIPTS</code>)</li> <li>What parameters each script accepts</li> <li>How to execute the command</li> </ul> <p>Once invoked, your script must return JSON-formatted results in a prescribed structure so SIERRA can visualize them in the investigation graph.</p>"},{"location":"invoker/#2-invoker-script-structure","title":"2. Invoker Script Structure","text":"<p>Each Invoker script is configured via a YAML file with the following sections:</p> YAML<pre><code># Optional: directories SIERRA searches for your script files\nPATHS:\n  - /path/to/script/directory\n  - /another/path\n\n# Mandatory: list of Invoker scripts to register\nSCRIPTS:\n  - Name: Subdomain Finder           # Unique script name\n    Description: \"Lookup subdomains of a domain\"\n    Params:\n      - Name: Domain                 # Parameter name\n        Description: \"Domain to query\" # Optional description\n        Type: STRING                 # Supported: STRING, FILE\n        Options:\n          - MANDATORY                # Options: PRIMARY, MANDATORY\n    Command: python subfinder.py {Domain}\n</code></pre> <ul> <li>PATHS (optional): A prioritized list of directories where SIERRA locates your script file.</li> <li>Name (mandatory): Unique identifier for your Invoker script.</li> <li>Description (optional): Brief summary of what the script does.</li> <li> <p>Params (mandatory): List of parameters:</p> </li> <li> <p>Name (mandatory)</p> </li> <li>Description (optional)</li> <li>Type (mandatory): <code>STRING</code> or <code>FILE</code></li> <li>Options (optional): e.g. <code>PRIMARY</code>, <code>MANDATORY</code></li> <li>Command (mandatory): The shell command to execute, with parameter placeholders like <code>{Domain}</code>.</li> </ul>"},{"location":"invoker/#3-result-formats","title":"3. Result Formats","text":"<p>Your script must output a JSON object that SIERRA can parse. There are three supported formats:</p>"},{"location":"invoker/#31-tree-type","title":"3.1 Tree Type","text":"<p>Use for hierarchical results.</p> JSON<pre><code>{\n  \"type\": \"Tree\",\n  \"results\": [\n    \"Entity A\",\n    {\n      \"Parent C\": [\"Child D\", \"Child E\"]\n    }\n  ]\n}\n</code></pre> <ul> <li><code>type</code>: must be <code>Tree</code></li> <li><code>results</code>: array of strings or nested objects (parent \ufffd children)</li> </ul>"},{"location":"invoker/#32-network-type","title":"3.2 Network Type","text":"<p>Use for graph/network relationships.</p> JSON<pre><code>{\n  \"type\": \"Network\",\n  \"origins\": [\"AliceID\"],\n  \"nodes\": [\n    {\"id\": \"AliceID\",   \"content\": \"Alice\"},\n    {\"id\": \"BobID\",     \"content\": \"Bob\"},\n    {\"id\": \"CharlieID\", \"content\": \"Charlie\"}\n  ],\n  \"edges\": [\n    {\"source\": \"AliceID\", \"target\": \"BobID\",     \"label\": \"friend\"},\n    {\"source\": \"AliceID\", \"target\": \"CharlieID\", \"label\": \"colleague\"}\n  ]\n}\n</code></pre> <ul> <li><code>type</code>: must be <code>Network</code></li> <li><code>origins</code>: list of origin node IDs</li> <li><code>nodes</code>: array of <code>{id, content}</code> objects</li> <li><code>edges</code>: array of <code>{source, target, label}</code></li> </ul>"},{"location":"invoker/#33-error-type","title":"3.3 Error Type","text":"<p>On errors, return:</p> JSON<pre><code>{ \"type\": \"Error\", \"message\": \"Error description\" }\n</code></pre> <p>SIERRA will display the error and halt the script execution gracefully.</p>"},{"location":"invoker/#4-example-invoker-configuration","title":"4. Example Invoker Configuration","text":"<p>Below is a full example of a subdomain lookup Invoker:</p> YAML<pre><code>PATHS:\n  - /opt/scripts\n  - /home/user/tools\n\nSCRIPTS:\n  - Name: Subdomain Finder\n    Description: \"Looks up subdomains using crt.sh\"\n    Params:\n      - Name: Domain\n        Description: \"Domain to query\"\n        Type: STRING\n        Options:\n          - PRIMARY\n          - MANDATORY\n    Command: python subfinder.py {Domain}\n</code></pre> <p>When invoked, SIERRA will locate <code>subfinder.py</code> in the given <code>PATHS</code>, pass the <code>{Domain}</code> argument, and expect a Tree or Network JSON output.</p>"},{"location":"invoker/#5-tips-best-practices","title":"5. Tips &amp; Best Practices","text":"<ul> <li>Validate Input: Check parameter presence and types, returning an <code>Error</code> JSON if invalid.</li> <li>Timeouts: Ensure long-running scripts implement timeouts to avoid blocking SIERRA.</li> <li>Logging: Write logs to <code>stderr</code> or a separate file to aid debugging without polluting JSON output.</li> <li>Reusability: Modularize code so dependency functions can be shared across multiple Invokers.</li> </ul> <p>Harness the power of SIERRA Invoker scripts to automate your investigative workflows and integrate your favorite tools seamlessly into the SIERRA platform.</p>"},{"location":"quickstart/","title":"Quick Start","text":""},{"location":"quickstart/#quickstart","title":"\ud83d\ude80 Quickstart","text":"<p>This guide helps you go from zero to a working Sierra Dev setup \u2014 where you can write structured invokers, generate standalone scripts, and produce CLI-ready YAML configs.</p>"},{"location":"quickstart/#1-create-your-first-invoker","title":"\ud83d\udcc1 1. Create Your First Invoker","text":"<p>In a file like <code>scripts/greet.py</code>, define an invoker:</p> Python<pre><code>import sierra\n\n# Define the invoker\ninvoker = sierra.InvokerScript(\n    name=\"greet\",\n    description=\"Prints a personalized greeting message.\"\n)\n\n# Dependency functions\n@invoker.dependancy\ndef random_function_one(param: int) -&gt; int:\n    return param * 2\n\n@invoker.dependancy\ndef random_function_two(message: str) -&gt; str:\n    return message.upper()\n\n@invoker.dependancy\ndef random_function_three(value: float) -&gt; float:\n    return value / 3.14\n\n@invoker.dependancy\ndef random_function_four(flag: bool) -&gt; bool:\n    return not flag\n\n# Main entrypoint\n@invoker.entry_point\ndef run(\n    name: sierra.Param[\n        str | None,\n        sierra.SierraOption(\n            description=\"The name of the person to greet.\",\n            mandatory=\"MANDATORY\"\n        )\n    ],\n    polite: sierra.Param[\n        bool | None,\n        sierra.SierraOption(\n            description=\"Whether to include a polite phrase in the greeting.\"\n        )\n    ] = False,\n) -&gt; None:\n    if name is None:\n        result = sierra.create_error_result(\"Missing mandatory parameter: name\")\n    else:\n        greeting = f\"Hello, {name}!\"\n        if polite:\n            greeting = f\"Good day to you, {name}!\"\n        result = sierra.create_tree_result([greeting])\n    print(result)\n\n# Loader function\ndef load(client: sierra.SierraDevelopmentClient) -&gt; None:\n    client.load_invoker(invoker)\n</code></pre>"},{"location":"quickstart/#2-load-the-client","title":"\u2699\ufe0f 2. Load the Client","text":"<p>In your driver script (e.g. <code>compile.py</code>):</p> Python<pre><code>import sierra\n\nclient = sierra.SierraDevelopmentClient(\n    environment_name=\"default_env\",\n    logger=sierra.UniversalLogger(\n        name=\"Sierra\",\n        level=sierra.sierra_internal_logger.LogLevel.DEBUG,\n    ),\n)\n\n# Load all scripts from the environment\nclient.load_invokers_from_scripts()\n\n# Compile to standalone Python + YAML config\nclient.compiler.compile()\n</code></pre>"},{"location":"quickstart/#3-what-compile-does","title":"\ud83c\udfd7\ufe0f 3. What <code>compile()</code> Does","text":"<p>It auto-generates:</p> <ul> <li>A standalone script (e.g. <code>invokers/greet.py</code>)</li> <li>A YAML entry for your CLI or automation config</li> <li>Command-line argument parsing and runtime validation</li> </ul> <p>Example compiled script:</p> Bash<pre><code>python invokers/greet.py Alice true\n</code></pre> <p>Example output:</p> JSON<pre><code>{\n  \"type\": \"tree\",\n  \"tree\": [\"Good day to you, Alice!\"]\n}\n</code></pre>"},{"location":"quickstart/#4-environment-layout","title":"\ud83d\udcc2 4. Environment Layout","text":"<p>Your project directory might look like:</p> Text Only<pre><code>\ud83d\udcc1 default_env/\n \u251c\u2500 scripts/\n \u2502   \u2514\u2500 greet.py\n \u251c\u2500 invokers/\n \u2502   \u2514\u2500 greet.py  \u2190 auto\u2011compiled\n \u251c\u2500 venv/\n \u251c\u2500 config.yaml   \u2190 auto\u2011generated\n \u2514\u2500 source\n</code></pre>"},{"location":"quickstart/#5-run-test","title":"\ud83e\uddea 5. Run &amp; Test","text":"<p>After compilation:</p> <ul> <li>CLI works with basic Python execution</li> <li>All validations (types, required params) are automatically checked</li> <li>Error and tree results are structured and JSON-compatible</li> </ul>"},{"location":"quickstart/#notes","title":"\ud83d\udccc Notes","text":"<ul> <li>Use <code>@invoker.entry_point</code> for the main logic</li> <li>Use <code>@invoker.dependancy</code> to register helpers</li> <li>Use <code>Param[...]</code> with <code>SierraOption(...)</code> for typed + validated inputs</li> <li>Client will pick up all scripts inside the <code>scripts/</code> directory</li> </ul>"},{"location":"quickstart/#learn-more","title":"\ud83e\udde0 Learn More","text":"<p>Check out:</p> <ul> <li>Plugin Development Guide</li> <li>Typing &amp; Linting</li> <li>Docstring &amp; Documentation</li> </ul>"},{"location":"results/","title":"Results","text":""},{"location":"results/#result-processing","title":"Result Processing","text":"<p>After your Invoker script runs, SIERRA reads its JSON\u202foutput and integrates it into the investigation graph according to the <code>type</code> field.</p>"},{"location":"results/#tree-results","title":"Tree Results","text":"JSON<pre><code>{\n  \"type\": \"Tree\",\n  \"results\": [ \u2026 ]\n}\n</code></pre> <ul> <li> <p>Interpretation:</p> </li> <li> <p>Each string in <code>results</code> becomes a leaf node.</p> </li> <li>Each object maps a parent node to its child array.</li> <li> <p>Effect in UI:</p> </li> <li> <p>Renders a collapsible hierarchy.</p> </li> <li>Parent nodes can be expanded to reveal children.</li> </ul>"},{"location":"results/#network-results","title":"Network Results","text":"JSON<pre><code>{\n  \"type\": \"Network\",\n  \"origins\": [ \u2026 ],\n  \"nodes\": [ \u2026 ],\n  \"edges\": [ \u2026 ]\n}\n</code></pre> <ul> <li> <p>Interpretation:</p> </li> <li> <p><code>origins</code> mark starting nodes in the graph.</p> </li> <li><code>nodes</code> defines all entities with unique IDs and content.</li> <li><code>edges</code> defines directed relationships (<code>source</code> \u2192 <code>target</code>) with optional labels.</li> <li> <p>Effect in UI:</p> </li> <li> <p>Displays an interactive node\u2011link diagram.</p> </li> <li>You can trace connections from each origin through the network.</li> </ul>"},{"location":"results/#error-results","title":"Error Results","text":"JSON<pre><code>{ \"type\": \"Error\", \"message\": \"\u2026\" }\n</code></pre> <ul> <li> <p>Interpretation:</p> </li> <li> <p>Any script error or validation failure.</p> </li> <li> <p>Effect in UI:</p> </li> <li> <p>Shows a prominent error banner with your <code>message</code>.</p> </li> <li>Halts further result rendering for that invocation.</li> </ul>"},{"location":"results/#internal-hanlding-of-results","title":"Internal hanlding of results?","text":"<p>Yes, this kit supports internal dealing of it.</p>"},{"location":"results/#tree-type-result","title":"Tree Type Result","text":"Example of tree type result."},{"location":"results/#sierra.create_tree_result","title":"sierra.create_tree_result","text":"Python<pre><code>create_tree_result(\n    results: list[typing.Union[str, dict[str, list[str]]]],\n) -&gt; dict[str, typing.Any]\n</code></pre> <p>Create a Tree type result.</p> PARAMETER DESCRIPTION <code>results</code> <p>The tree results.</p> <p> TYPE: <code>list[Union[str, dict[str, list[str]]]]</code> </p> RETURNS DESCRIPTION <code>TreeResult</code> <p>The formatted tree result.</p>"},{"location":"results/#network-type-result","title":"Network Type Result","text":"Example of network type result."},{"location":"results/#sierra.create_network_result","title":"sierra.create_network_result","text":"Python<pre><code>create_network_result(\n    origins: list[str],\n    nodes: list[dict[str, str]],\n    edges: list[dict[str, str]],\n) -&gt; dict[str, str]\n</code></pre> <p>Create a Network type result.</p> PARAMETER DESCRIPTION <code>origins</code> <p>List of origin node IDs.</p> <p> TYPE: <code>list[str]</code> </p> <code>nodes</code> <p>List of node definitions.</p> <p> TYPE: <code>list[dict[str, str]]</code> </p> <code>edges</code> <p>List of edge definitions.</p> <p> TYPE: <code>list[dict[str, str]]</code> </p> RETURNS DESCRIPTION <code>NetworkResult</code> <p>The formatted network result.</p>"},{"location":"results/#manage-errrors","title":"Manage Errrors","text":""},{"location":"results/#sierra.create_error_result","title":"sierra.create_error_result","text":"Python<pre><code>create_error_result(message: str) -&gt; dict[str, str]\n</code></pre> <p>Create an Error type result.</p> PARAMETER DESCRIPTION <code>message</code> <p>The error message.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>ErrorResult</code> <p>The formatted error result.</p>"},{"location":"sierra-dev/","title":"Sierra Dev","text":""},{"location":"sierra-dev/#sierra-dev","title":"sierra-dev","text":"<p>\ud83d\ude80 Overview</p> <p>sierra-dev is a Python framework for building and managing invoker scripts that run across multiple Sierra nodes during any investigation. It provides a simple, intuitive API, strict typing, and a plugin ecosystem to tailor the framework to your workflow.</p>"},{"location":"sierra-dev/#project-goals","title":"\ud83c\udfaf Project Goals","text":"<ul> <li>Provide a robust and flexible foundation for invoker script management</li> <li>Offer a user-friendly API for building, compiling, and deploying Sierra applications</li> <li>Enable extensibility through plugins, custom configurations, and offline-safe design</li> </ul>"},{"location":"sierra-dev/#key-features","title":"\ud83d\udd11 Key Features","text":"<ul> <li>Modular Architecture: Decouple core components into interchangeable modules</li> <li>Invoker Script Management: Define, compile, and execute invoker scripts seamlessly</li> <li>Plugin Support: Extend sierra-dev capabilities with custom plugins</li> <li>Strict Typing: Full PEP 484 annotations and NumPy-style docstrings</li> <li>Offline-First: Zero external dependencies\u2014ideal for air-gapped environments</li> <li>Ruff-Compliant: Built-in linting rules ensure consistent style and formatting</li> </ul>"},{"location":"guides/","title":"Read First","text":""},{"location":"guides/#guides","title":"Guides","text":"<p>In this section you can find various detailed guides to help you maintain code quality, enforce standards, and extend Sierra\u2011SDK through plugins.</p> <ul> <li> <p> Typing &amp; Type Hints</p> <p>Sierra\u2011SDK relies on static typing for clarity and safety. Learn how to configure and run MyPy (or Pyright), interpret errors, and leverage type hints effectively.</p> <p> Learn more</p> </li> <li> <p> Linting &amp; Formatting</p> <p>Keep your codebase consistent and readable with Ruff linting rules and Black auto\u2011formatting. This guide shows you how to configure both tools and integrate them into your workflow.</p> <p> Learn more</p> </li> <li> <p> Documentation &amp; Docstring Standards</p> <p>Generate and maintain clear API reference docs using MkDocs and mkdocstrings. Follow best practices for NumPy\u2011style docstrings to ensure your code is always well documented.</p> <p> Learn more</p> </li> <li> <p> Plugin Development</p> <p>Extend Sierra\u2011SDK\u2019s functionality by writing custom plugins. Learn how to subclass the base plugin interface, register invokers, and structure your plugin for seamless integration.</p> <p> Learn more</p> </li> </ul>"},{"location":"guides/documentation/","title":"Documentation","text":""},{"location":"guides/documentation/#documentation-docstring-standards","title":"Documentation &amp; Docstring Standards","text":"<p>Maintaining clear and consistent documentation is a core principle of Sierra\u2011SDK. This guide walks you through how to document your code using NumPy-style docstrings, and how to generate clean developer documentation using MkDocs and mkdocstrings.</p>"},{"location":"guides/documentation/#why-docstrings-matter","title":"Why Docstrings Matter","text":"<p>Sierra\u2011SDK enforces strict standards around function and class documentation. Every public-facing function, method, and class should use NumPy-style docstrings to:</p> <ul> <li>Improve code readability.</li> <li>Enable automated documentation generation.</li> <li>Ensure consistency across all plugins and modules.</li> </ul>"},{"location":"guides/documentation/#docstring-format-numpy-style","title":"Docstring Format: NumPy Style","text":"<p>NumPy-style docstrings are clean, structured, and ideal for static parsing. Below is a canonical example for a function:</p> Python<pre><code>def process_data(data: list[str], verbose: bool = False) -&gt; dict[str, int]:\n    \"\"\"\n    Processes a list of strings and returns word counts.\n\n    Parameters\n    ----------\n    data : list of str\n        The input list of strings to process.\n    verbose : bool, optional\n        If True, prints detailed logging output. Defaults to False.\n\n    Returns\n    -------\n    dict of str to int\n        A dictionary mapping each word to its occurrence count.\n    \"\"\"\n</code></pre>"},{"location":"guides/documentation/#section-ordering","title":"Section Ordering","text":"<p>Follow this order strictly:</p> <ol> <li>Short Summary</li> <li>Extended Description (optional)</li> <li>Parameters</li> <li>Returns</li> <li>Raises (if applicable)</li> <li>Examples (if useful)</li> <li>See Also / Notes (optional)</li> </ol>"},{"location":"guides/documentation/#required-fields","title":"Required Fields","text":"<ul> <li> <p>Every parameter must include:</p> </li> <li> <p>Name</p> </li> <li>Type</li> <li>Description</li> <li> <p>Every return value must include:</p> </li> <li> <p>Type</p> </li> <li>Description</li> </ul>"},{"location":"guides/documentation/#common-standards","title":"Common Standards","text":"<ul> <li>Use <code>list[str]</code> not <code>List[str]</code> \u2013 always use lowercase generics for modern typing.</li> <li>Do not use Markdown inside docstrings.</li> <li>Start all descriptions with capital letters and end sentences with periods.</li> </ul>"},{"location":"guides/documentation/#mkdocs-integration","title":"MkDocs Integration","text":"<p>Sierra\u2011SDK uses <code>mkdocstrings</code> to render docstrings into clean, searchable documentation pages.</p> <p>In <code>mkdocs.yml</code>:</p> YAML<pre><code>plugins:\n  - mkdocstrings:\n      handlers:\n        python:\n          options:\n            docstring_style: numpy\n            show_root_heading: true\n            show_root_full_path: false\n            show_symbol_type_heading: true\n            merge_init_into_class: true\n            show_signature: true\n</code></pre>"},{"location":"guides/documentation/#folder-layout","title":"Folder Layout","text":"<p>Make sure your repo structure supports autodoc discovery:</p> Text Only<pre><code>\ud83d\udcc1 sierra\n \u251c\u2500 __init__.py\n \u251c\u2500 core/\n \u251c\u2500 invoker/\n \u2514\u2500 plugins/\n</code></pre> <p>Each file should use properly formatted module-level docstrings:</p> Python<pre><code>\"\"\"\nInvoker module for Sierra Dev.\n\nThis module contains core logic for building and registering standalone invoker scripts.\n\"\"\"\n</code></pre>"},{"location":"guides/documentation/#best-practices","title":"Best Practices","text":"<ul> <li>Document every public function and class.</li> <li>Avoid documenting private methods unless necessary.</li> <li>Keep summaries to a single sentence.</li> <li>Use imperative voice: \u201cReturn X\u201d, not \u201cReturns X\u201d.</li> </ul>"},{"location":"guides/documentation/#tools-to-enforce-compliance","title":"Tools to Enforce Compliance","text":"<p>Use Ruff to enforce docstring rules:</p> TOML<pre><code>[tool.ruff.lint]\nselect = [\"D\"]\nignore = [\"D205\", \"D417\"]\n</code></pre> <p>Use MyPy to catch undocumented return values or bad type hints.</p>"},{"location":"guides/documentation/#example-documented-invoker-entry-point","title":"Example: Documented Invoker Entry Point","text":"Python<pre><code>@invoker.entry_point\ndef run(\n    name: sierra.Param[str, sierra.SierraOption(description=\"Name to greet.\", mandatory=\"MANDATORY\")],\n    polite: sierra.Param[bool, sierra.SierraOption(description=\"Use polite tone.\")]\n) -&gt; None:\n    \"\"\"\n    Entry point to execute the greeting logic.\n\n    Parameters\n    ----------\n    name : str\n        Name of the person to greet.\n    polite : bool\n        Whether to greet politely.\n\n    Returns\n    -------\n    None\n    \"\"\"\n</code></pre>"},{"location":"guides/documentation/#summary","title":"Summary","text":"<p>Using proper documentation practices ensures:</p> <p>\u2705 Clean auto-generated docs \u2705 Easier onboarding for contributors \u2705 Long-term maintainability</p> <p>Follow this guide strictly for all official and third-party Sierra\u2011SDK plugins.</p>"},{"location":"guides/linting/","title":"Linting & Formatting","text":""},{"location":"guides/linting/#linting-guide-ruff","title":"Linting Guide (Ruff)","text":"<p>Sierra\u2011SDK enforces strict, automated linting using Ruff. This ensures your code is readable, safe, PEP8-compliant, and production\u2011ready across all modules, plugins, invokers, and core logic.</p>"},{"location":"guides/linting/#configuration-summary","title":"\ud83d\udd27 Configuration Summary","text":"<p>The Ruff config is defined in <code>pyproject.toml</code>:</p> TOML<pre><code>[tool.ruff]\nextend-exclude = [\"examples/*\", \".venv/*\"]\nline-length = 79\n\n[tool.ruff.lint]\nselect = [\n    \"E\", \"F\", \"I\", \"TCH\", \"C\", \"N\",\n    \"D2\", \"D3\", \"D415\", \"D417\", \"D418\", \"D419\",\n    \"ASYNC\", \"Q\", \"RSE\", \"SIM\", \"RUF\"\n]\nignore = [\n    \"F405\", \"F403\", \"E501\", \"D205\", \"D417\", \"C901\"\n]\nfixable = [\"I\", \"TCH\", \"D\"]\n\n[tool.ruff.lint.pydocstyle]\nconvention = \"numpy\"\n\n[tool.ruff.lint.isort]\nforce-single-line = true\n\n[tool.ruff.format]\ndocstring-code-format = true\n</code></pre>"},{"location":"guides/linting/#enabled-rule-categories","title":"\u2705 Enabled Rule Categories","text":"Code Category Purpose <code>E</code> Pycodestyle PEP8 syntax violations (indent, spacing, etc.) <code>F</code> Pyflakes Undefined vars, unused imports <code>I</code> isort Enforces import order and grouping <code>TCH</code> Type Checking Missing annotations, wrong type locations <code>C</code> Complexity Cyclomatic and McCabe complexity checks <code>N</code> Naming Naming style conventions (e.g. <code>snake_case</code>) <code>D2/D3</code> Docstring Style Enforces formatting in multi-line docstrings <code>D415</code> Section Terminators Ensures docstring sections end with colons <code>D417</code> Arg Match Arguments in docstring must match function signature <code>D418</code> Capitalization Docstring sections must start with uppercase <code>D419</code> Final Line Docstring ends with newline <code>ASYNC</code> Async Rules Coroutine-specific patterns and misuse <code>Q</code> Quotes Consistent use of <code>'</code> or <code>\"</code> <code>RSE</code> Raise Statements Proper use of <code>raise</code> syntax <code>SIM</code> Simplifications Unnecessary code, can be written more simply <code>RUF</code> Ruff Internals Ruff's own useful auto-checks"},{"location":"guides/linting/#ignored-rules-temporarily-or-internally-allowed","title":"\ud83d\udeab Ignored Rules (Temporarily or Internally Allowed)","text":"Code Reason <code>F403</code> <code>import *</code> allowed internally for auto\u2011loader code <code>F405</code> Allow references from wildcard imports internally <code>E501</code> Line length is tracked separately (<code>line-length = 79</code>) <code>D205</code> One-line summary may be followed immediately by description <code>D417</code> Signature mismatches may occur in some CLI generators <code>C901</code> High complexity allowed temporarily during refactor stages"},{"location":"guides/linting/#auto-fixable-rules","title":"\ud83e\uddf9 Auto-Fixable Rules","text":"<p>Ruff can automatically fix:</p> <ul> <li><code>I</code>: Import ordering</li> <li><code>TCH</code>: Type-checking fixes (e.g. move annotations to stubs)</li> <li><code>D</code>: Many docstring formatting errors</li> </ul> <p>Run:</p> Bash<pre><code>ruff check . --fix\n</code></pre>"},{"location":"guides/linting/#docstrings-numpy-convention","title":"\ud83d\udcda Docstrings: NumPy Convention","text":"<p>Use NumPy-style docstrings in all modules. Ruff validates your structure, spacing, and style.</p>"},{"location":"guides/linting/#correct","title":"\u2705 Correct","text":"Python<pre><code>def add(a: int, b: int) -&gt; int:\n    \"\"\"\n    Add two numbers.\n\n    Parameters\n    ----------\n    a : int\n        First number.\n    b : int\n        Second number.\n\n    Returns\n    -------\n    int\n        Sum of both.\n    \"\"\"\n    return a + b\n</code></pre>"},{"location":"guides/linting/#incorrect","title":"\u274c Incorrect","text":"Python<pre><code>def add(a, b):\n    \"\"\"adds\"\"\"\n    return a + b\n</code></pre>"},{"location":"guides/linting/#import-order-one-per-line","title":"\ud83d\udce6 Import Order: One Per Line","text":"Python<pre><code># Good\nimport os\nimport sys\n\n# Bad\nimport os, sys\n</code></pre>"},{"location":"guides/linting/#best-practices-summary","title":"\ud83e\udde0 Best Practices Summary","text":"Do \u2705 Avoid \u274c One import per line Multiple imports on same line Always annotate every function Leaving return type off Use NumPy docstrings Google or plain docstrings Keep line length \u2264 79 Long unwrapped lines Run <code>ruff check --fix</code> often Ignoring doc errors or imports"},{"location":"guides/linting/#run-linting","title":"\ud83e\uddea Run Linting","text":"<p>Check your code:</p> Bash<pre><code>ruff check .\n</code></pre> <p>Autofix common issues:</p> Bash<pre><code>ruff check . --fix\n</code></pre>"},{"location":"guides/linting/#reminder","title":"\ud83d\udccc Reminder","text":"<p>Ruff runs fast, has no runtime cost, and gives immediate feedback. Use it constantly to enforce code health and Sierra\u2011SDK quality.</p>"},{"location":"guides/plugins/","title":"Plugins","text":""},{"location":"guides/plugins/#plugin-development","title":"Plugin Development","text":"<p>Learn how to build and register a standalone invoker script using the Sierra\u2011SDK plugin system. This guide walks you through defining dependencies, input parameters, result outputs, and the plugin loader function.</p>"},{"location":"guides/plugins/#step-1-import-sierra","title":"Step 1 \u2014 Import Sierra","text":"Python<pre><code>import sierra\nimport requests\n</code></pre> <p>Use the core <code>sierra</code> module to access all plugin interfaces, decorators, parameter wrappers, and result constructors.</p>"},{"location":"guides/plugins/#step-2-define-an-invokerscript","title":"Step 2 \u2014 Define an <code>InvokerScript</code>","text":"<p>Start by creating an <code>InvokerScript</code> object. This acts as the root definition of your plugin logic. And putting in requirements inside <code>invoker.requirement</code></p> Python<pre><code>invoker = sierra.InvokerScript(\n    name=\"greet\",\n    description=\"Prints a personalized greeting message.\"\n)\n\n\ninvoker.requirement([\"requests\"])\n</code></pre>"},{"location":"guides/plugins/#step-3-register-dependencies","title":"Step 3 \u2014 Register Dependencies","text":"<p>You can define helper functions that are not exposed as command-line parameters but are needed by your entry point.</p> Python<pre><code>@invoker.dependency\ndef random_function_one(param: int) -&gt; int:\n    return param * 2\n\n@invoker.dependency\ndef random_function_two(message: str) -&gt; str:\n    return message.upper()\n</code></pre>"},{"location":"guides/plugins/#step-4-define-the-entry-point","title":"Step 4 \u2014 Define the Entry Point","text":"<p>Mark the main function using <code>@invoker.entry_point</code>. Input arguments should use <code>sierra.Param</code> and <code>sierra.SierraOption</code>.</p> Python<pre><code>@invoker.entry_point\ndef run(\n    name: sierra.Param[\n        str | None,\n        sierra.SierraOption(description=\"Name of the person to greet.\", mandatory=\"MANDATORY\")\n    ],\n    polite: sierra.Param[\n        bool | None,\n        sierra.SierraOption(description=\"Include polite greeting?\", mandatory=None)\n    ] = False\n) -&gt; None:\n    if name is None:\n        result = sierra.create_error_result(\"Missing mandatory parameter: name\")\n    else:\n        greeting = f\"Hello, {name}!\"\n        if polite:\n            greeting = f\"Good day to you, {name}!\"\n        result = sierra.create_tree_result([greeting])\n    print(result)\n</code></pre>"},{"location":"guides/plugins/#step-5-load-the-plugin","title":"Step 5 \u2014 Load the Plugin","text":"<p>The plugin must define a <code>load()</code> function. This hook is invoked by the Sierra plugin loader to register your invoker.</p> Python<pre><code>def load(client: sierra.SierraDevelopmentClient) -&gt; None:\n    client.load_invoker(invoker)\n</code></pre>"},{"location":"guides/plugins/#summary","title":"Summary","text":"Component Purpose <code>InvokerScript()</code> Defines a new plugin/invoker <code>@invoker.dependency</code> Adds a helper function to the script <code>@invoker.entry_point</code> Marks the main callable <code>sierra.Param[...]</code> Wraps a parameter with typing and options metadata <code>load()</code> Registers the invoker into the plugin system <code>create_tree_result()</code> Generates structured tree output <code>create_error_result()</code> Returns a formatted error <p>Once created, this invoker becomes discoverable by Sierra CLI or GUI runners.</p>"},{"location":"guides/typing/","title":"Typing & Type Hints","text":""},{"location":"guides/typing/#typing-type-hinting","title":"Typing &amp; Type Hinting","text":"<p>Sierra\u2011SDK uses strict static typing to ensure safety, clarity, and predictability in all components. This guide helps you apply best practices using <code>mypy</code>, <code>pyright</code>, and Python\u2019s <code>typing</code> system across scripts, invokers, and plugins.</p>"},{"location":"guides/typing/#type-annotations-the-basics","title":"\u2705 Type Annotations: The Basics","text":"<p>Use fully annotated function signatures. Avoid implicit <code>Any</code>.</p> Python<pre><code>def add(a: int, b: int) -&gt; int:\n    return a + b\n</code></pre> <p>\u2714\ufe0f Always declare return types \u2714\ufe0f Prefer <code>str</code>, <code>int</code>, <code>bool</code>, <code>float</code>, <code>None</code>, <code>list[str]</code>, <code>dict[str, int]</code>, etc.</p>"},{"location":"guides/typing/#advanced-typing-in-sierra","title":"\u2705 Advanced Typing in Sierra","text":""},{"location":"guides/typing/#sierraparam","title":"<code>sierra.Param[...]</code>","text":"<p>Wrap input parameters using <code>Param[T, SierraOption]</code>. This supports type-checked command-line inputs.</p> Python<pre><code>@invoker.entry_point\ndef run(\n    name: sierra.Param[\n        str | None,\n        sierra.SierraOption(description=\"User name\", mandatory=\"MANDATORY\")\n    ]\n) -&gt; None:\n    ...\n</code></pre> <p>\ud83d\udca1 Sierra type-wrappers are fully compatible with MyPy and Pyright.</p>"},{"location":"guides/typing/#callable-types","title":"\u2705 Callable Types","text":"<p>When registering dependencies, use explicit function signatures.</p> Python<pre><code>@invoker.dependency\ndef compute(value: int) -&gt; int:\n    ...\n</code></pre> <p>Never leave them untyped\u2014this breaks type checking across invoker dependency graphs.</p>"},{"location":"guides/typing/#use-typeddict-for-json-like-objects","title":"\u2705 Use TypedDict for JSON-like Objects","text":"<p>For structured dicts (e.g. plugin config or JSON schemas), use <code>typing.TypedDict</code>.</p> Python<pre><code>import typing\n\nclass PluginConfig(typing.TypedDict):\n    name: str\n    version: str\n    enabled: bool\n</code></pre>"},{"location":"guides/typing/#use-literal-for-constrained-values","title":"\u2705 Use Literal for Constrained Values","text":"<p>Use <code>typing.Literal</code> for fixed string options like <code>\"MANDATORY\"</code>, <code>\"PRIMARY\"</code>, etc.</p> Python<pre><code>def set_flag(mode: typing.Literal[\"MANDATORY\", \"OPTIONAL\"]) -&gt; None:\n    ...\n</code></pre>"},{"location":"guides/typing/#mypy-and-pyright","title":"\u2705 MyPy and Pyright","text":""},{"location":"guides/typing/#configure-mypyini","title":"Configure <code>mypy.ini</code>","text":"INI<pre><code>[mypy]\nstrict = True\nignore_missing_imports = True\ndisallow_untyped_defs = True\ncheck_untyped_defs = True\nwarn_unused_ignores = True\n</code></pre>"},{"location":"guides/typing/#pyright-config-pyrightconfigjson","title":"Pyright config (<code>pyrightconfig.json</code>)","text":"JSON<pre><code>{\n  \"typeCheckingMode\": \"strict\",\n  \"reportMissingTypeStubs\": false\n}\n</code></pre>"},{"location":"guides/typing/#best-practices-summary","title":"\ud83e\udde0 Best Practices Summary","text":"Rule Example or Tool Use full type signatures <code>def func(x: int) -&gt; str</code> Use <code>Param[T, Option]</code> For all invoker arguments No implicit <code>Any</code> Use <code>mypy --strict</code> Wrap dicts with <code>TypedDict</code> <code>class MyDict(TypedDict)</code> Validate literals <code>Literal[\"A\", \"B\", \"C\"]</code>"},{"location":"guides/typing/#static-safe","title":"\ud83d\udd12 Static = Safe","text":"<p>Static typing helps Sierra:</p> <ul> <li>Prevent runtime errors</li> <li>Enable smart auto-complete</li> <li>Ensure plugin contracts are valid</li> <li>Document APIs without ambiguity</li> </ul> <p>\u2757\ufe0f All contributions to Sierra\u2011SDK must pass <code>mypy</code> and <code>pyright</code> with zero errors.</p>"},{"location":"sierra/client/","title":"Sierra Client","text":""},{"location":"sierra/client/#sierra-client","title":"Sierra Client","text":"<p>The <code>sierra.client</code> module exposes the <code>SierraDevelopmentClient</code> class, which orchestrates environment setup, script loading, caching, and compilation.</p> Initializing SierraDevelopmentClient Python<pre><code>import pathlib\nfrom sierra.client import SierraDevelopmentClient\nfrom sierra.internal.logger import UniversalLogger, LogLevel\n\nclient = SierraDevelopmentClient(\n    environment_path=pathlib.Path(\"default_env\"),\n    environment_name=\"default_env\",\n    logger=UniversalLogger(name=\"Sierra\", level=LogLevel.DEBUG),\n)\n\nclient.load_invokers_from_scripts()\nclient.compiler.compile()\n</code></pre>"},{"location":"sierra/client/#sierra.client","title":"sierra.client","text":""},{"location":"sierra/client/#sierra.client-classes","title":"Classes","text":""},{"location":"sierra/client/#sierra.client.InvokerWithLoad","title":"InvokerWithLoad","text":"<p>               Bases: <code>typing.Protocol</code></p> <p>Protocol for invoker scripts with a load method.</p> PARAMETER DESCRIPTION <code>client</code> <p>The client instance to use for loading the invoker script.</p> <p> TYPE: <code>SierraDevelopmentClient</code> </p>"},{"location":"sierra/client/#sierra.client.InvokerWithLoad-functions","title":"Functions","text":"load Link Python<pre><code>load(client: SierraDevelopmentClient) -&gt; None\n</code></pre> <p>Load the invoker script.</p> PARAMETER DESCRIPTION <code>client</code> <p>The client instance to use for loading the invoker script.</p> <p> TYPE: <code>SierraDevelopmentClient</code> </p>"},{"location":"sierra/client/#sierra.client.ClientParams","title":"ClientParams","text":"<p>               Bases: <code>typing.TypedDict</code></p> <p>A typed dictionary for passing client parameters.</p> ATTRIBUTE DESCRIPTION <code>logger</code> <p>The logger instance for capturing client activity.</p> <p> TYPE: <code>(UniversalLogger, optional)</code> </p> <code>cache</code> <p>The cache manager instance for handling caching operations.</p> <p> TYPE: <code>(CacheManager, optional)</code> </p> Notes <p>This TypedDict structure is used to encapsulate optional client parameters that can be provided to the SierraDevelopmentClient.</p>"},{"location":"sierra/client/#sierra.client.ClientParams-attributes","title":"Attributes","text":"logger <code>instance-attribute</code> Link Python<pre><code>logger: sierra_internal_logger.UniversalLogger\n</code></pre> <code></code> cache <code>instance-attribute</code> Link Python<pre><code>cache: sierra_internal_cache.CacheManager\n</code></pre>"},{"location":"sierra/client/#sierra.client.SierraDevelopmentClient","title":"SierraDevelopmentClient","text":"Python<pre><code>SierraDevelopmentClient(\n    environment_path: pathlib.Path = pathlib.Path.cwd(),\n    environment_name: str = \"default_env\",\n    **kwargs: typing.Unpack[ClientParams],\n)\n</code></pre> <p>Initialize the Sierra Development Client.</p> PARAMETER DESCRIPTION <code>environment_path</code> <p>Path to the root of the Sierra environment.</p> <p> TYPE: <code>pathlib.Path</code> DEFAULT: <code>pathlib.Path.cwd()</code> </p> <code>environment_name</code> <p>Name of the environment configuration to load.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'default_env'</code> </p> <code>**kwargs</code> <p>Optional: logger and cache manager.</p> <p> TYPE: <code>ClientParams</code> DEFAULT: <code>{}</code> </p>"},{"location":"sierra/client/#sierra.client.SierraDevelopmentClient-attributes","title":"Attributes","text":"logger <code>instance-attribute</code> Link Python<pre><code>logger: sierra_internal_logger.UniversalLogger = kwargs.get(\n    \"logger\", sierra_internal_logger.UniversalLogger()\n)\n</code></pre> <code></code> environment <code>instance-attribute</code> Link Python<pre><code>environment: sierra_core_environment.SierraDevelopmentEnvironment = sierra_core_environment.SierraDevelopmentEnvironment(\n    client=self,\n    name=environment_name,\n    path=environment_path,\n)\n</code></pre> <code></code> cache <code>instance-attribute</code> Link Python<pre><code>cache: sierra_internal_cache.CacheManager = kwargs.get(\n    \"cache\",\n    sierra_internal_cache.CacheManager(\n        cache_dir=self.environment.config_path / \"cache\"\n    ),\n)\n</code></pre> <code></code> http_client <code>instance-attribute</code> Link Python<pre><code>http_client: httpx.Client = httpx.Client(\n    headers={\"User-Agent\": \"Sierra-dev/1.0\"}\n)\n</code></pre> <code></code> loader <code>instance-attribute</code> Link Python<pre><code>loader: sierra_core_loader.SierraSideloader = (\n    sierra_core_loader.SierraSideloader(client=self)\n)\n</code></pre> <code></code> invokers <code>instance-attribute</code> Link Python<pre><code>invokers: list[sierra_invoker.InvokerScript] = []\n</code></pre> <code></code> builder <code>instance-attribute</code> Link Python<pre><code>builder = sierra_core_builder.SierraInvokerBuilder(\n    client=self\n)\n</code></pre> <code></code> compiler <code>instance-attribute</code> Link Python<pre><code>compiler = sierra_core_compiler.SierraCompiler(client=self)\n</code></pre>"},{"location":"sierra/client/#sierra.client.SierraDevelopmentClient-functions","title":"Functions","text":"load_invoker Link Python<pre><code>load_invoker(invoker: sierra_invoker.InvokerScript) -&gt; None\n</code></pre> <p>Register a single invoker instance with the client.</p> PARAMETER DESCRIPTION <code>invoker</code> <p>An instance of an InvokerScript.</p> <p> TYPE: <code>InvokerScript</code> </p> <code></code> unload_invoker Link Python<pre><code>unload_invoker(\n    invoker: sierra_invoker.InvokerScript,\n) -&gt; None\n</code></pre> <p>Unregister a single invoker instance from the client.</p> PARAMETER DESCRIPTION <code>invoker</code> <p>An instance of an InvokerScript.</p> <p> TYPE: <code>InvokerScript</code> </p> <code></code> load_invokers_from_scripts Link Python<pre><code>load_invokers_from_scripts() -&gt; None\n</code></pre> <p>Automatically discover and load all InvokerScript subclasses from .py files in the environment's scripts directory.</p>"},{"location":"sierra/invoker/","title":"Invoker","text":""},{"location":"sierra/invoker/#invoker","title":"Invoker","text":"<p>Define and manage invoker scripts in the Sierra Dev. Invoker scripts are used to execute specific actions in a controlled environment.</p> Invoker Example Python<pre><code>import sierra\n\n# Define an InvokerScript with dependencies and an entry point\ninvoker = sierra.InvokerScript(\n    name=\"example\",\n    description=\"An example invoker script.\"\n)\n\n@invoker.dependency\ndef helper_function(param: int) -&gt; int:\n    return param + 1\n\n@invoker.entry_point\ndef run(param: sierra.Param[int, sierra.SierraOption(description=\"An integer parameter.\")]) -&gt; None:\n    result = helper_function(param)\n    print(f\"Result: {result}\")\n\n# Register the invoker\nsierra.register_invoker(invoker)\n</code></pre>"},{"location":"sierra/invoker/#sierra.invoker","title":"sierra.invoker","text":""},{"location":"sierra/invoker/#sierra.invoker-classes","title":"Classes","text":""},{"location":"sierra/invoker/#sierra.invoker.InvokerScript","title":"InvokerScript","text":"Python<pre><code>InvokerScript(name: str, description: str | None = None)\n</code></pre> <p>A wrapper for creating Sierra invoker scripts that generates config.yaml and argparse-compatible scripts.</p> <p>This class is used to define a script with its parameters, then generate: 1. A standalone Python script with argparse handling 2. A YAML configuration for Sierra 3. Proper JSON output formatting</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>The unique name of the script.</p> <p> TYPE: <code>str</code> </p> <code>description</code> <p>A short description of the script.</p> <p> TYPE: <code>str | None</code> </p> <code>params</code> <p>List of parameter metadata.</p> <p> TYPE: <code>list[SierraInvokerParam]</code> </p> <code>http_client</code> <p>Optional HTTP client used for external requests.</p> <p> TYPE: <code>httpx.Client | None</code> </p> <code>logger</code> <p>Logger instance for capturing script activity.</p> <p> TYPE: <code>UniversalLogger</code> </p> <code>_entry_point</code> <p>The registered Python function.</p> <p> TYPE: <code>_TCallable | None</code> </p> <code>_output_dir</code> <p>Directory to output generated files.</p> <p> TYPE: <code>Path | None</code> </p>"},{"location":"sierra/invoker/#sierra.invoker.InvokerScript-attributes","title":"Attributes","text":"name <code>instance-attribute</code> Link Python<pre><code>name = name\n</code></pre> <code></code> description <code>instance-attribute</code> Link Python<pre><code>description = description\n</code></pre> <code></code> params <code>instance-attribute</code> Link Python<pre><code>params: list[sierra_abc_sierra.SierraInvokerParam] = []\n</code></pre> <code></code> deps <code>instance-attribute</code> Link Python<pre><code>deps: list[_TCallable] = []\n</code></pre> <code></code> requirements <code>instance-attribute</code> Link Python<pre><code>requirements: list[str] = []\n</code></pre> <code></code> command <code>instance-attribute</code> Link Python<pre><code>command: str = ''\n</code></pre> <code></code> filename <code>instance-attribute</code> Link Python<pre><code>filename: pathlib.Path\n</code></pre>"},{"location":"sierra/invoker/#sierra.invoker.InvokerScript-functions","title":"Functions","text":"verify_signature <code>staticmethod</code> Link Python<pre><code>verify_signature(func: _TCallable) -&gt; None\n</code></pre> <p>Verifies that all parameters are properly typed with SierraOption metadata. Raises TypeError if any parameter lacks SierraOption typing.</p> PARAMETER DESCRIPTION <code>func</code> <p>The function to verify.</p> <p> TYPE: <code>_TCallable</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If any parameter lacks proper SierraOption annotation.</p> <code></code> entry_point Link Python<pre><code>entry_point(func: _TCallable) -&gt; _TCallable\n</code></pre> <p>Register a Python function as an invoker script.</p> <p>This extracts parameter metadata and prepares the function for code generation.</p> PARAMETER DESCRIPTION <code>func</code> <p>The function to register.</p> <p> TYPE: <code>_TCallable</code> </p> RETURNS DESCRIPTION <code>_TCallable</code> <p>The original function (unchanged).</p> <code></code> dependancy Link Python<pre><code>dependancy(func: _TCallable) -&gt; _TCallable\n</code></pre> <code></code> requirement Link Python<pre><code>requirement(requirement: list[str]) -&gt; None\n</code></pre> <code></code> set_command Link Python<pre><code>set_command(command_string: str) -&gt; None\n</code></pre>"},{"location":"sierra/options/","title":"Options","text":""},{"location":"sierra/options/#options","title":"Options","text":"<p>In Sierra\u2011SDK, every Invoker entry\u2011point parameter must be wrapped with <code>Param[...]</code>, supplying a <code>SierraOption</code> to describe its behavior and validation rules.</p> Options Example Python<pre><code>import sierra\n\ndef example(foo: sierra.Param[str, sierra.SierraOption(description=\"Foo is a foo\")])-&gt;None:\n\"\"\"\nFoo is a string, the options add a metadata called description.\n\"\"\"\nresult = sierra.create_tree_result([f\"{foo}\"])\nprint(result)\n</code></pre>"},{"location":"sierra/options/#sierra.options","title":"sierra.options","text":""},{"location":"sierra/options/#sierra.options-attributes","title":"Attributes","text":""},{"location":"sierra/options/#sierra.options.Param","title":"Param  <code>module-attribute</code>","text":"Python<pre><code>Param = typing.Annotated\n</code></pre>"},{"location":"sierra/options/#sierra.options-classes","title":"Classes","text":""},{"location":"sierra/options/#sierra.options.SierraOption","title":"SierraOption","text":"Python<pre><code>SierraOption(\n    *,\n    description: str = \"\",\n    mandatory: typing.Literal[\"MANDATORY\"] | None = None,\n)\n</code></pre> <p>               Bases: <code>typing.Generic[_T]</code></p> <p>Wrapper for marking a function parameter as a Sierra option.</p> PARAMETER DESCRIPTION <code>description</code> <p>A short description of the parameter.</p> <p> TYPE: <code>str</code> DEFAULT: <code>\"\"</code> </p> <code>mandatory</code> <p>Flags the parameter as mandatory.</p> <p> TYPE: <code>typing.Literal['MANDATORY'] | None</code> DEFAULT: <code>None</code> </p>"},{"location":"sierra/options/#sierra.options.SierraOption-attributes","title":"Attributes","text":"description <code>instance-attribute</code> Link Python<pre><code>description = description\n</code></pre> <code></code> mandatory <code>instance-attribute</code> Link Python<pre><code>mandatory = mandatory\n</code></pre>"},{"location":"sierra/abc/base/","title":"Base ABC","text":""},{"location":"sierra/abc/base/#base-classes","title":"Base Classes","text":"<p>The <code>sierra.abc.base</code> module provides foundational abstract classes for Sierra core objects, ensuring consistent initialization, configuration loading, and error handling.</p> Extending SierraCoreObject Python<pre><code>from sierra.abc.base import SierraCoreObject\nfrom sierra.internal.logger import UniversalLogger, LogLevel\nfrom sierra.client import SierraDevelopmentClient\n\n# Initialize a dummy client for demonstration\nclient = SierraDevelopmentClient(logger=UniversalLogger(level=LogLevel.DEBUG))\n\nclass MyCoreComponent(SierraCoreObject):\n    \"\"\"\n    Example component that leverages SierraCoreObject for standardized behavior.\n    \"\"\"\n    def __init__(self, client, name: str):\n        super().__init__(client)\n        self.name = name\n        self.client.logger.log(f\"MyCoreComponent '{self.name}' initialized\", \"info\")\n\n    def perform_action(self):\n        self.client.logger.log(f\"Performing action in {self.name}\", \"debug\")\n\n# Usage\ncomponent = MyCoreComponent(client, name=\"Example\")\ncomponent.perform_action()\n</code></pre>"},{"location":"sierra/abc/base/#sierra.abc.base","title":"sierra.abc.base","text":""},{"location":"sierra/abc/base/#sierra.abc.base-classes","title":"Classes","text":""},{"location":"sierra/abc/base/#sierra.abc.base.SierraABC","title":"SierraABC","text":"<p>               Bases: <code>typing.TypedDict</code></p> <p>Base class for all Sierra ABCs.</p> <p>This class is used to define the structure of Sierra ABCs.</p>"},{"location":"sierra/abc/sierra/","title":"Sierra ABC","text":""},{"location":"sierra/abc/sierra/#abstract-base-classes","title":"Abstract Base Classes","text":"<p>The <code>sierra.abc.sierra</code> module defines base protocols and classes for building custom Sierra components, such as invoker parameters and plugin interfaces.</p> Working with SierraInvokerParam Python<pre><code>from sierra.abc.sierra import SierraInvokerParam, SierraCoreObject\n\n# Create a parameter definition\nparam = SierraInvokerParam(\n    Name=\"domain\",\n    Type=str,\n    Description=\"The domain to query\",\n    Options=\"MANDATORY\"\n)\n\n# SierraCoreObject provides common initialization for core components\nclass MyComponent(SierraCoreObject):\n    def __init__(self, client):\n        super().__init__(client)\n        client.logger.log(\"MyComponent initialized\", \"info\")\n</code></pre>"},{"location":"sierra/abc/sierra/#sierra.abc.sierra","title":"sierra.abc.sierra","text":""},{"location":"sierra/abc/sierra/#sierra.abc.sierra-classes","title":"Classes","text":""},{"location":"sierra/abc/sierra/#sierra.abc.sierra.SierraInvokerParam","title":"SierraInvokerParam","text":"<p>               Bases: <code>sierra_abc_base.SierraABC</code></p> <p>Represents a single parameter for an invoker script.</p> ATTRIBUTE DESCRIPTION <code>Name</code> <p>The parameter's name.</p> <p> TYPE: <code>str</code> </p> <code>Description</code> <p>Human-readable description of the parameter.</p> <p> TYPE: <code>str | None</code> </p> <code>Type</code> <p>The data type of the parameter (e.g., 'STRING', 'FILE').</p> <p> TYPE: <code>str</code> </p> <code>Options</code> <p>List of flags, such as 'PRIMARY' or 'MANDATORY'.</p> <p> TYPE: <code>list[str] | None</code> </p>"},{"location":"sierra/abc/sierra/#sierra.abc.sierra.SierraInvokerParam-attributes","title":"Attributes","text":"Name <code>instance-attribute</code> Link Python<pre><code>Name: str\n</code></pre> <code></code> Type <code>instance-attribute</code> Link Python<pre><code>Type: str\n</code></pre> <code></code> Description <code>instance-attribute</code> Link Python<pre><code>Description: str | None\n</code></pre> <code></code> Options <code>instance-attribute</code> Link Python<pre><code>Options: typing.Literal['MANDATORY'] | None\n</code></pre>"},{"location":"sierra/abc/sierra/#sierra.abc.sierra.SierraInvokerScript","title":"SierraInvokerScript","text":"<p>               Bases: <code>sierra_abc_base.SierraABC</code></p> <p>Represents an invoker script definition.</p> ATTRIBUTE DESCRIPTION <code>Name</code> <p>Unique name of the script.</p> <p> TYPE: <code>str</code> </p> <code>Description</code> <p>Brief description of the script.</p> <p> TYPE: <code>str | None</code> </p> <code>Params</code> <p>List of parameters for the script.</p> <p> TYPE: <code>list[SierraInvokerParam]</code> </p> <code>Command</code> <p>Shell or Python command template, with placeholders for parameters.</p> <p> TYPE: <code>str</code> </p>"},{"location":"sierra/abc/sierra/#sierra.abc.sierra.SierraInvokerScript-attributes","title":"Attributes","text":"Name <code>instance-attribute</code> Link Python<pre><code>Name: str\n</code></pre> <code></code> Description <code>instance-attribute</code> Link Python<pre><code>Description: str | None\n</code></pre> <code></code> Params <code>instance-attribute</code> Link Python<pre><code>Params: list[SierraInvokerParam] | None\n</code></pre> <code></code> Command <code>instance-attribute</code> Link Python<pre><code>Command: str | None\n</code></pre>"},{"location":"sierra/abc/sierra/#sierra.abc.sierra.SierraConfig","title":"SierraConfig","text":"<p>               Bases: <code>sierra_abc_base.SierraABC</code></p> <p>Top-level configuration for SIERRA invoker scripts.</p> ATTRIBUTE DESCRIPTION <code>PATHS</code> <p>Optional list of directories to search for scripts.</p> <p> TYPE: <code>list[str] | None</code> </p> <code>SCRIPTS</code> <p>Definitions of all invoker scripts.</p> <p> TYPE: <code>list[SierraInvokerScript]</code> </p>"},{"location":"sierra/abc/sierra/#sierra.abc.sierra.SierraConfig-attributes","title":"Attributes","text":"PATHS <code>instance-attribute</code> Link Python<pre><code>PATHS: list[str] | None\n</code></pre> <code></code> SCRIPTS <code>instance-attribute</code> Link Python<pre><code>SCRIPTS: list[SierraInvokerScript]\n</code></pre>"},{"location":"sierra/core/builder/","title":"Builder","text":""},{"location":"sierra/core/builder/#builder","title":"Builder","text":"<p>The <code>sierra.core.builder</code> module is responsible for building invoker scripts in the Sierra Dev. It provides functionality to assemble standalone scripts from invoker definitions, handling imports, dependencies, and entry points.</p> Creating a builder? Python<pre><code>import sierra\n\n# Define an InvokerScript\ninvoker = sierra.InvokerScript(\n    name=\"example\",\n    description=\"An example invoker script.\"\n)\n\n# Define the entry point\n@invoker.entry_point\ndef run(param: sierra.Param[int, sierra.SierraOption(description=\"An integer parameter.\")]) -&gt; None:\n    print(f\"Running with parameter: {param}\")\n\n# Use SierraInvokerBuilder to build the script\nbuilder = sierra.core.builder.SierraInvokerBuilder(client=sierra_client)\nscript = builder.build(invoker)\n\n# Output the generated script\nprint(script)\n</code></pre>"},{"location":"sierra/core/builder/#sierra.core.builder","title":"sierra.core.builder","text":""},{"location":"sierra/core/builder/#sierra.core.builder-classes","title":"Classes","text":""},{"location":"sierra/core/builder/#sierra.core.builder.SierraInvokerBuilder","title":"SierraInvokerBuilder","text":"Python<pre><code>SierraInvokerBuilder(\n    client: sierra_client.SierraDevelopmentClient,\n)\n</code></pre> <p>               Bases: <code>sierra_core_base.SierraCoreObject</code></p> <p>Builder for Sierra invoker scripts.</p> <p>Generates commands, extracts and cleans imports, handles dependencies, and constructs a main entry-point with type-checked parameters.</p> PARAMETER DESCRIPTION <code>client</code> <p>The client instance containing the environment and logger.</p> <p> TYPE: <code>SierraClient</code> </p> ATTRIBUTE DESCRIPTION <code>client</code> <p>The client instance provided during initialization.</p> <p> TYPE: <code>SierraClient</code> </p> <p>Initialize a SierraCoreObject.</p> PARAMETER DESCRIPTION <code>client</code> <p>The Sierra development client.</p> <p> TYPE: <code>SierraDevelopmentClient</code> </p> Notes <p>Logs each initialization step via the client's logger.</p>"},{"location":"sierra/core/builder/#sierra.core.builder.SierraInvokerBuilder-attributes","title":"Attributes","text":"client <code>instance-attribute</code> Link Python<pre><code>client = client\n</code></pre>"},{"location":"sierra/core/builder/#sierra.core.builder.SierraInvokerBuilder-functions","title":"Functions","text":"generate_command Link Python<pre><code>generate_command(\n    invoker: sierra_invoker.InvokerScript,\n) -&gt; str\n</code></pre> <p>Construct the CLI command to invoke the given script in the virtual environment.</p> PARAMETER DESCRIPTION <code>invoker</code> <p>The script to generate a command for.</p> <p> TYPE: <code>sierra_invoker.InvokerScript</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The constructed command.</p> <code></code> extract_imports Link Python<pre><code>extract_imports(\n    invoker: sierra_invoker.InvokerScript,\n) -&gt; list[str]\n</code></pre> <p>Extract all import statements from an invoker script.</p> PARAMETER DESCRIPTION <code>invoker</code> <p>The invoker script from which to extract imports.</p> <p> TYPE: <code>sierra_invoker.InvokerScript</code> </p> RETURNS DESCRIPTION <code>list of str</code> <p>A list of import statements found in the script.</p> Notes <p>This function reads the file associated with the provided invoker and parses it to extract all import statements, including standard imports and from-import statements.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; invoker = SierraInvokerScript(\"example.py\")\n&gt;&gt;&gt; builder.extract_imports(invoker)\n['import os', 'from sys import path']\n</code></pre> <code></code> get_filtered_imports Link Python<pre><code>get_filtered_imports(\n    invoker: sierra_invoker.InvokerScript,\n) -&gt; list[str]\n</code></pre> <p>Retrieve all import statements excluding those from the sierra namespace.</p> PARAMETER DESCRIPTION <code>invoker</code> <p>The invoker script from which to extract non-sierra imports.</p> <p> TYPE: <code>sierra_invoker.InvokerScript</code> </p> RETURNS DESCRIPTION <code>list of str</code> <p>A list of import statements excluding sierra namespace imports.</p> Notes <p>This function utilizes the <code>extract_imports</code> method to gather all imports and filters out those that are related to the sierra namespace.</p> <code></code> get_required_sierra_imports Link Python<pre><code>get_required_sierra_imports() -&gt; list[str]\n</code></pre> <p>Get only the essential sierra imports needed for the standalone script.</p> <code></code> remove_sierra_imports Link Python<pre><code>remove_sierra_imports(\n    invoker: sierra_invoker.InvokerScript,\n) -&gt; str\n</code></pre> <p>Strip out all imports from the 'sierra' namespace in a script.</p> PARAMETER DESCRIPTION <code>invoker</code> <p>The invoker script from which to remove sierra imports.</p> <p> TYPE: <code>sierra_invoker.InvokerScript</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The source code of the invoker with all sierra imports removed.</p> <code></code> get_deps_source Link Python<pre><code>get_deps_source(\n    invoker: sierra_invoker.InvokerScript,\n) -&gt; list[str]\n</code></pre> <p>Extract the source code for each dependency function and remove any decorators.</p> PARAMETER DESCRIPTION <code>invoker</code> <p>The invoker script containing the dependencies.</p> <p> TYPE: <code>InvokerScript</code> </p> RETURNS DESCRIPTION <code>list of str</code> <p>A list of source code strings for each dependency function without decorators.</p> <code></code> get_entry_point_source Link Python<pre><code>get_entry_point_source(\n    invoker: sierra_invoker.InvokerScript,\n) -&gt; str\n</code></pre> <p>Extract and rebuild the entry point function with simple type annotations.</p> PARAMETER DESCRIPTION <code>invoker</code> <p>The invoker script containing the entry point.</p> <p> TYPE: <code>InvokerScript</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The source code of the entry point function with simple type annotations.</p> <code></code> get_parameter_type_string Link Python<pre><code>get_parameter_type_string(\n    param: sierra_abc_sierra.SierraInvokerParam,\n) -&gt; str\n</code></pre> <p>Get the proper type string for a parameter including Optional wrapper.</p> PARAMETER DESCRIPTION <code>param</code> <p>The parameter to get the type string for.</p> <p> TYPE: <code>SierraInvokerParam</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The type string for the parameter.</p> <code></code> get_arg_type_checking Link Python<pre><code>get_arg_type_checking(\n    param: sierra_abc_sierra.SierraInvokerParam,\n) -&gt; str\n</code></pre> <p>Generate runtime presence and type checks for a single parameter.</p> PARAMETER DESCRIPTION <code>param</code> <p>The parameter to generate type checks for.</p> <p> TYPE: <code>SierraInvokerParam</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The type checking code as a single string.</p> <code></code> get_sys_args_parsing Link Python<pre><code>get_sys_args_parsing(\n    invoker: sierra_invoker.InvokerScript,\n) -&gt; list[str]\n</code></pre> <p>Generate sys.argv parsing with proper type conversion and validation.</p> PARAMETER DESCRIPTION <code>invoker</code> <p>The invoker script containing parameters for parsing.</p> <p> TYPE: <code>sierra_invoker.InvokerScript</code> </p> RETURNS DESCRIPTION <code>list of str</code> <p>A list of source code lines for argument parsing.</p> <code></code> create_type_safe_main Link Python<pre><code>create_type_safe_main(\n    invoker: sierra_invoker.InvokerScript,\n) -&gt; str\n</code></pre> <p>Build a type-safe main guard with comprehensive error handling.</p> PARAMETER DESCRIPTION <code>invoker</code> <p>The invoker script containing parameters for parsing.</p> <p> TYPE: <code>sierra_invoker.InvokerScript</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The type-safe main guard.</p> <code></code> build Link Python<pre><code>build(invoker: sierra_invoker.InvokerScript) -&gt; str\n</code></pre> <p>Assemble the full standalone script.</p> PARAMETER DESCRIPTION <code>invoker</code> <p>The invoker script to generate a standalone script for.</p> <p> TYPE: <code>sierra_invoker.InvokerScript</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The full standalone script.</p> <code></code> generate_file_header Link Python<pre><code>generate_file_header(\n    invoker: sierra_invoker.InvokerScript,\n) -&gt; str\n</code></pre> <p>Generate file header with metadata.</p> PARAMETER DESCRIPTION <code>invoker</code> <p>The invoker script to generate a standalone script for.</p> <p> TYPE: <code>sierra_invoker.InvokerScript</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The file header with metadata.</p> <code></code> validate_script_syntax Link Python<pre><code>validate_script_syntax(script: str) -&gt; bool\n</code></pre> <p>Check the syntax of a generated script.</p> PARAMETER DESCRIPTION <code>script</code> <p>The script content to validate.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the script's syntax is valid, False if a syntax error occurs.</p> <code></code> get_metadata Link Python<pre><code>get_metadata(\n    invoker: sierra_invoker.InvokerScript,\n) -&gt; dict[str, typing.Any]\n</code></pre> <p>Retrieve metadata about the invoker.</p> PARAMETER DESCRIPTION <code>invoker</code> <p>The invoker script instance.</p> <p> TYPE: <code>sierra_invoker.InvokerScript</code> </p> RETURNS DESCRIPTION <code>dict of str to Any</code> <p>Metadata dictionary containing invoker information.</p>"},{"location":"sierra/core/checker/","title":"Checker","text":""},{"location":"sierra/core/checker/#this-has-to-be-created-within-the-library-first","title":"This has to be created within the library first","text":""},{"location":"sierra/core/compiler/","title":"Compiler","text":""},{"location":"sierra/core/compiler/#compiler","title":"Compiler","text":"<p>The <code>sierra.core.compiler</code> module is responsible for taking registered invoker scripts and producing standalone Python scripts along with the corresponding YAML configuration.</p> Compiling invoker scripts Python<pre><code>import pathlib\nimport sierra\n\n# Initialize your SierraDevelopmentClient\nclient = sierra.SierraDevelopmentClient(\n    environment_path=pathlib.Path(\"default_env\"),\n    environment_name=\"default_env\",\n    logger=sierra.UniversalLogger(name=\"Sierra\", level=sierra.sierra_internal_logger.LogLevel.DEBUG),\n)\n\n# Discover and register all invokers\nclient.load_invokers_from_scripts()\n\n# Compile into standalone scripts and config.yaml\nclient.compiler.compile()\n</code></pre>"},{"location":"sierra/core/compiler/#sierra.core.compiler","title":"sierra.core.compiler","text":""},{"location":"sierra/core/compiler/#sierra.core.compiler-classes","title":"Classes","text":""},{"location":"sierra/core/compiler/#sierra.core.compiler.SierraCompiler","title":"SierraCompiler","text":"Python<pre><code>SierraCompiler(\n    client: sierra_client.SierraDevelopmentClient,\n)\n</code></pre> <p>               Bases: <code>sierra_core_base.SierraCoreObject</code></p> <p>Compiler for Sierra invoker scripts and YAML configuration.</p> <p>Generates standalone invoker scripts in the environment's invokers directory and writes a config.yaml file with PATHS and SCRIPTS entries without external dependencies.</p> PARAMETER DESCRIPTION <code>client</code> <p>The client to use for logging and accessing environment information.</p> <p> TYPE: <code>SierraClient</code> </p> ATTRIBUTE DESCRIPTION <code>client</code> <p>The client instance provided during initialization.</p> <p> TYPE: <code>SierraClient</code> </p> METHOD DESCRIPTION <code>set_invoker_commands</code> <p>Generate and set the CLI command string for each registered invoker.</p> <code>build_and_save_scripts</code> <p>Write each invoker's generated standalone script to the invokers directory.</p> <code>make_invoker_yaml</code> <p>Construct a YAML configuration string for all registered invokers without relying on external YAML libraries.</p> <code>compile</code> <p>Complete compilation process: 1. Generate CLI command strings for invokers 2. Write standalone Python scripts 3. Write config.yaml in the root of the environment.</p> <p>Initialize a SierraCoreObject.</p> PARAMETER DESCRIPTION <code>client</code> <p>The Sierra development client.</p> <p> TYPE: <code>SierraDevelopmentClient</code> </p> Notes <p>Logs each initialization step via the client's logger.</p>"},{"location":"sierra/core/compiler/#sierra.core.compiler.SierraCompiler-attributes","title":"Attributes","text":"client <code>instance-attribute</code> Link Python<pre><code>client = client\n</code></pre>"},{"location":"sierra/core/compiler/#sierra.core.compiler.SierraCompiler-functions","title":"Functions","text":"set_invoker_commands Link Python<pre><code>set_invoker_commands() -&gt; None\n</code></pre> <p>Generate and set the CLI command string for each registered invoker.</p> <code></code> build_and_save_scripts Link Python<pre><code>build_and_save_scripts() -&gt; None\n</code></pre> <p>Write each invoker's generated standalone script to the invokers directory.</p> <code></code> make_invoker_yaml Link Python<pre><code>make_invoker_yaml() -&gt; str\n</code></pre> <p>Construct a YAML configuration string for all registered invokers without relying on external YAML libraries.</p> RETURNS DESCRIPTION <code>str</code> <p>YAML-formatted configuration.</p> <code></code> compile Link Python<pre><code>compile() -&gt; None\n</code></pre> <p>Complete compilation process: 1. Generate CLI command strings for invokers 2. Write standalone Python scripts 3. Write config.yaml in the root of the environment.</p>"},{"location":"sierra/core/environment/","title":"Environment","text":""},{"location":"sierra/core/environment/#environment","title":"Environment","text":"<p>The <code>sierra.core.environment</code> module handles creation, initialization, and teardown of the on\u2011disk Sierra development environment\u2014setting up config directories, the virtualenv, scripts folder, and more.</p> Initializing your Sierra environment Python<pre><code>import pathlib\nimport sierra.core.environment as environment\n\n# Given a SierraDevelopmentClient instance `client`...\nproject_root = pathlib.Path(\"/path/to/project\")\nenv = environment.SierraDevelopmentEnvironment(\n    client=client,\n    name=\"default_env\",            # logical environment name\n    path=project_root      # base path for all Sierra files\n)\n\n# Create config/, scripts/, venv/, invokers/ directories\nenv.init()\n</code></pre>"},{"location":"sierra/core/environment/#sierra.core.environment","title":"sierra.core.environment","text":""},{"location":"sierra/core/environment/#sierra.core.environment-classes","title":"Classes","text":""},{"location":"sierra/core/environment/#sierra.core.environment.Environment","title":"Environment","text":"<p>               Bases: <code>typing.TypedDict</code></p>"},{"location":"sierra/core/environment/#sierra.core.environment.Environment-attributes","title":"Attributes","text":"name <code>instance-attribute</code> Link Python<pre><code>name: str\n</code></pre> <code></code> path <code>instance-attribute</code> Link Python<pre><code>path: pathlib.Path\n</code></pre>"},{"location":"sierra/core/environment/#sierra.core.environment.SierraDevelopmentEnvironment","title":"SierraDevelopmentEnvironment","text":"Python<pre><code>SierraDevelopmentEnvironment(\n    client: sierra_client.SierraDevelopmentClient,\n    **kwrags: typing.Unpack[Environment],\n)\n</code></pre> <p>               Bases: <code>sierra_core_base.SierraCoreObject</code></p> <p>Manages the lifecycle of a SIERRA development environment.</p> <p>Logs each step to the client's logger.</p> <p>Initialize a SierraDevelopmentEnvironment.</p> PARAMETER DESCRIPTION <code>client</code> <p>The client instance to use for logging and API interactions.</p> <p> TYPE: <code>SierraDevelopmentClient</code> </p> <code>**kwrags</code> <p>Environment parameters.</p> <p> TYPE: <code>Environment</code> DEFAULT: <code>{}</code> </p>"},{"location":"sierra/core/environment/#sierra.core.environment.SierraDevelopmentEnvironment-attributes","title":"Attributes","text":"client <code>instance-attribute</code> Link Python<pre><code>client = client\n</code></pre> <code></code> name <code>instance-attribute</code> Link Python<pre><code>name: str = kwrags.get('name', 'sierra_config')\n</code></pre> <code></code> path <code>instance-attribute</code> Link Python<pre><code>path: pathlib.Path = kwrags.get('path', pathlib.Path.cwd())\n</code></pre> <code></code> config_path <code>instance-attribute</code> Link Python<pre><code>config_path: pathlib.Path = self.path / self.name\n</code></pre> <code></code> venv_path <code>instance-attribute</code> Link Python<pre><code>venv_path: pathlib.Path = self.config_path / 'venv'\n</code></pre> <code></code> scripts_path <code>instance-attribute</code> Link Python<pre><code>scripts_path: pathlib.Path = self.config_path / 'scripts'\n</code></pre> <code></code> sierra_env_path <code>instance-attribute</code> Link Python<pre><code>sierra_env_path: pathlib.Path = self.config_path\n</code></pre> <code></code> invokers_path <code>instance-attribute</code> Link Python<pre><code>invokers_path: pathlib.Path = (\n    self.sierra_env_path / \"invokers\"\n)\n</code></pre> <code></code> os_type <code>instance-attribute</code> Link Python<pre><code>os_type: str = platform.system().lower()\n</code></pre>"},{"location":"sierra/core/environment/#sierra.core.environment.SierraDevelopmentEnvironment-functions","title":"Functions","text":"init Link Python<pre><code>init() -&gt; None\n</code></pre> <p>Initialize the environment.</p> <p>Logs each step to the client's logger.</p> <code></code> destroy Link Python<pre><code>destroy() -&gt; None\n</code></pre> <p>Remove the environment configuration directory.</p> <p>Logs each step of the operation.</p> RAISES DESCRIPTION <code>OSError</code> <p>If the directory removal fails.</p> <code></code> exists Link Python<pre><code>exists() -&gt; bool\n</code></pre> <p>Check if the environment configuration directory exists.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if the directory exists.</p> <code></code> list_contents Link Python<pre><code>list_contents() -&gt; typing.List[str]\n</code></pre> <p>List the contents of the environment configuration directory.</p> RETURNS DESCRIPTION <code>list of str</code> <p>List of file names in the configuration directory.</p> RAISES DESCRIPTION <code>SierraPathError</code> <p>If the configuration directory does not exist.</p> <code></code> install_dependencies Link Python<pre><code>install_dependencies(\n    requirements_file: typing.Optional[pathlib.Path] = None,\n) -&gt; None\n</code></pre> <p>Install dependencies from a requirements file into the virtual environment.</p> PARAMETER DESCRIPTION <code>requirements_file</code> <p>Path to the requirements file. If None or the file does not exist, the installation is skipped.</p> <p> TYPE: <code>pathlib.Path</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>SierraExecutionError</code> <p>If pip is not found in the virtual environment or if the installation of dependencies fails.</p> <code></code> activate_instructions Link Python<pre><code>activate_instructions() -&gt; str\n</code></pre> <p>Generate the command string for activating the virtual environment.</p> RETURNS DESCRIPTION <code>str</code> <p>The activation command string for the appropriate OS environment.</p> Notes <p>This function constructs the activation command for virtual environments on both Windows and Unix-like systems.</p>"},{"location":"sierra/core/loader/","title":"Loader","text":""},{"location":"sierra/core/loader/#loader","title":"Loader","text":"<p>The <code>sierra.core.loader</code> module is responsible for loading compiled Sierra invoker scripts.</p> Loading an invoker Python<pre><code>import sierra\n\n# Create an instance of SierraSideloader with the Sierra client\nloader = sierra.SierraSideloader(client=...)\n\n# Populate the sideloader by pulling new files from all sources\n# This will cache all valid `.py` scripts from the configured sources\nloader.populate()\n</code></pre>"},{"location":"sierra/core/loader/#sierra.core.loader","title":"sierra.core.loader","text":""},{"location":"sierra/core/loader/#sierra.core.loader-classes","title":"Classes","text":""},{"location":"sierra/core/loader/#sierra.core.loader.SierraSideloader","title":"SierraSideloader","text":"Python<pre><code>SierraSideloader(\n    client: sierra_client.SierraDevelopmentClient,\n)\n</code></pre> <p>               Bases: <code>sierra_core_base.SierraCoreObject</code></p> <p>A sideloader that mimics APT-like behavior for fetching and managing Python invoker scripts from GitHub sources. Handles downloading, caching, and installing .py files only.</p> PARAMETER DESCRIPTION <code>client</code> <p>A reference to the Sierra development client.</p> <p> TYPE: <code>sierra_client.SierraDevelopmentClient</code> </p> <p>Initialize the SierraSideloader.</p> PARAMETER DESCRIPTION <code>client</code> <p>A reference to the Sierra development client.</p> <p> TYPE: <code>SierraDevelopmentClient</code> </p> RAISES DESCRIPTION <code>SierraPathError</code> <p>If the configuration path or source file does not exist.</p>"},{"location":"sierra/core/loader/#sierra.core.loader.SierraSideloader-attributes","title":"Attributes","text":"client <code>instance-attribute</code> Link Python<pre><code>client = client\n</code></pre> <code></code> cache <code>instance-attribute</code> Link Python<pre><code>cache = self.client.cache\n</code></pre> <code></code> path <code>instance-attribute</code> Link Python<pre><code>path: pathlib.Path = self.client.environment.config_path\n</code></pre> <code></code> sources <code>instance-attribute</code> Link Python<pre><code>sources: list[str] = [\n    line.strip() for line in f if line.strip()\n]\n</code></pre>"},{"location":"sierra/core/loader/#sierra.core.loader.SierraSideloader-functions","title":"Functions","text":"populate Link Python<pre><code>populate() -&gt; None\n</code></pre> <p>Pulls new files from all sources and caches all valid <code>.py</code> scripts.</p> <code></code> update Link Python<pre><code>update() -&gt; None\n</code></pre> <p>Refreshes the sideloader by pulling from all sources again.</p> <code></code> install Link Python<pre><code>install(name: str) -&gt; None\n</code></pre> <p>Installs a cached .py script into the Sierra environment's script directory.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the file to install (without <code>.py</code>).</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>SierraCacheError</code> <p>If the file is not found in the cache.</p> <code></code> search Link Python<pre><code>search(query: str) -&gt; list[str]\n</code></pre> <p>Searches for scripts in the cache by partial name match.</p> PARAMETER DESCRIPTION <code>query</code> <p>The search keyword.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>List[str]</code> <p>Matching script names.</p> <code></code> list_available Link Python<pre><code>list_available() -&gt; list[str]\n</code></pre> <p>Lists all <code>.py</code> script packages currently cached (including from disk).</p> RETURNS DESCRIPTION <code>List[str]</code> <p>Cached script names.</p> <code></code> info Link Python<pre><code>info(name: str) -&gt; dict[str, typing.Any]\n</code></pre> <p>Returns metadata about a cached script.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the cached script.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Metadata of the script including cache entry details.</p> RAISES DESCRIPTION <code>SierraCacheError</code> <p>If script not found in cache.</p> <code></code> cleanup_expired Link Python<pre><code>cleanup_expired() -&gt; int\n</code></pre> <p>Manually clean up expired cache entries.</p> RETURNS DESCRIPTION <code>int</code> <p>Number of entries removed.</p> <code></code> get_cache_stats Link Python<pre><code>get_cache_stats() -&gt; dict[str, typing.Any]\n</code></pre> <p>Get comprehensive cache statistics.</p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Cache statistics including file counts and sizes.</p>"},{"location":"sierra/internal/cache/","title":"Cache","text":""},{"location":"sierra/internal/cache/#cache-manager","title":"Cache Manager","text":"<p>The <code>sierra.internal.cache</code> module provides a simple file\u2011based cache for speeding up repeated operations (e.g., sideloader scans, compilation outputs).</p> Using the CacheManager Python<pre><code>from pathlib import Path\nfrom sierra.internal.cache import CacheManager\n\n# Create a cache directory inside your environment\ncache_dir = Path(\"default_env\") / \"cache\"\ncache = CacheManager(cache_dir=cache_dir)\n\n# Store a value in the cache\ncache.set(\"last_run_scripts\", [\"greet.py\", \"scan.py\"])\n\n# Retrieve a cached value (or None if missing)\nscripts = cache.get(\"last_run_scripts\")\nprint(scripts)  # [\"greet.py\", \"scan.py\"]\n</code></pre>"},{"location":"sierra/internal/cache/#sierra.internal.cache","title":"sierra.internal.cache","text":""},{"location":"sierra/internal/cache/#sierra.internal.cache-classes","title":"Classes","text":""},{"location":"sierra/internal/cache/#sierra.internal.cache.CompressionType","title":"CompressionType","text":"<p>               Bases: <code>Enum</code></p> <p>Compression types for cache entries.</p>"},{"location":"sierra/internal/cache/#sierra.internal.cache.CompressionType-attributes","title":"Attributes","text":"NONE <code>class-attribute</code> <code>instance-attribute</code> Link Python<pre><code>NONE = 'none'\n</code></pre> <code></code> GZIP <code>class-attribute</code> <code>instance-attribute</code> Link Python<pre><code>GZIP = 'gzip'\n</code></pre>"},{"location":"sierra/internal/cache/#sierra.internal.cache.CacheEntry","title":"CacheEntry  <code>dataclass</code>","text":"Python<pre><code>CacheEntry(\n    key: str,\n    value: typing.Any,\n    created_at: float,\n    expires_at: typing.Optional[float] = None,\n    compression: CompressionType = CompressionType.NONE,\n    size_bytes: int = 0,\n    access_count: int = 0,\n    last_accessed: float = 0.0,\n)\n</code></pre> <p>Represents a cache entry with metadata.</p>"},{"location":"sierra/internal/cache/#sierra.internal.cache.CacheEntry-attributes","title":"Attributes","text":"key <code>instance-attribute</code> Link Python<pre><code>key: str\n</code></pre> <code></code> value <code>instance-attribute</code> Link Python<pre><code>value: typing.Any\n</code></pre> <code></code> created_at <code>instance-attribute</code> Link Python<pre><code>created_at: float\n</code></pre> <code></code> expires_at <code>class-attribute</code> <code>instance-attribute</code> Link Python<pre><code>expires_at: typing.Optional[float] = None\n</code></pre> <code></code> compression <code>class-attribute</code> <code>instance-attribute</code> Link Python<pre><code>compression: CompressionType = CompressionType.NONE\n</code></pre> <code></code> size_bytes <code>class-attribute</code> <code>instance-attribute</code> Link Python<pre><code>size_bytes: int = 0\n</code></pre> <code></code> access_count <code>class-attribute</code> <code>instance-attribute</code> Link Python<pre><code>access_count: int = 0\n</code></pre> <code></code> last_accessed <code>class-attribute</code> <code>instance-attribute</code> Link Python<pre><code>last_accessed: float = 0.0\n</code></pre>"},{"location":"sierra/internal/cache/#sierra.internal.cache.CacheManager","title":"CacheManager","text":"Python<pre><code>CacheManager(\n    cache_dir: typing.Optional[pathlib.Path] = None,\n    max_memory_entries: int = 1000,\n    cleanup_interval: float = 3600,\n    auto_cleanup: bool = True,\n)\n</code></pre> <p>A full-featured cache manager with SQLite-backed persistence, TTL expiration, auto-cleanup, compression, and efficient key enumeration.</p> <p>Features: - SQLite-backed metadata storage for fast key enumeration - Separate file storage for large values - Memory cache for frequently accessed items - TTL support with automatic cleanup - Compression support (gzip) - Thread-safe operations - Access statistics tracking - Atomic operations</p> <p>Initialize the CacheManager.</p> PARAMETER DESCRIPTION <code>cache_dir</code> <p>Directory for cache storage. If None, uses OS-appropriate location.</p> <p> TYPE: <code>pathlib.Path</code> DEFAULT: <code>None</code> </p> <code>max_memory_entries</code> <p>Maximum number of entries to keep in memory cache.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> <code>cleanup_interval</code> <p>Interval in seconds between automatic cleanup runs.</p> <p> TYPE: <code>float</code> DEFAULT: <code>3600</code> </p> <code>auto_cleanup</code> <p>Whether to automatically clean up expired entries.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>"},{"location":"sierra/internal/cache/#sierra.internal.cache.CacheManager-functions","title":"Functions","text":"set Link Python<pre><code>set(\n    key: str,\n    value: typing.Any,\n    ttl: typing.Optional[float] = None,\n    persist: bool = True,\n    compress: bool = False,\n) -&gt; None\n</code></pre> <p>Store a value in the cache.</p> PARAMETER DESCRIPTION <code>key</code> <p>Cache key.</p> <p> TYPE: <code>str</code> </p> <code>value</code> <p>Value to cache.</p> <p> TYPE: <code>Any</code> </p> <code>ttl</code> <p>Time to live in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> <code>persist</code> <p>Whether to persist to disk (default: True).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>compress</code> <p>Whether to compress the value.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code></code> get Link Python<pre><code>get(key: str) -&gt; typing.Optional[typing.Any]\n</code></pre> <p>Retrieve a value from the cache.</p> PARAMETER DESCRIPTION <code>key</code> <p>Cache key.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Any or None</code> <p>The cached value or None if not found/expired.</p> <code></code> exists Link Python<pre><code>exists(key: str) -&gt; bool\n</code></pre> <p>Check if a key exists and is not expired.</p> PARAMETER DESCRIPTION <code>key</code> <p>Cache key.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the key exists and is valid.</p> <code></code> delete Link Python<pre><code>delete(key: str) -&gt; None\n</code></pre> <p>Delete a cache entry.</p> PARAMETER DESCRIPTION <code>key</code> <p>Cache key.</p> <p> TYPE: <code>str</code> </p> <code></code> clear Link Python<pre><code>clear() -&gt; None\n</code></pre> <p>Clear all cache entries.</p> <code></code> keys Link Python<pre><code>keys(include_expired: bool = False) -&gt; typing.List[str]\n</code></pre> <p>Get all cache keys.</p> PARAMETER DESCRIPTION <code>include_expired</code> <p>Whether to include expired keys.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>List[str]</code> <p>List of cache keys.</p> <code></code> cleanup Link Python<pre><code>cleanup() -&gt; int\n</code></pre> <p>Manually clean up expired entries.</p> RETURNS DESCRIPTION <code>int</code> <p>Number of entries removed.</p> <code></code> stats Link Python<pre><code>stats() -&gt; typing.Dict[str, typing.Any]\n</code></pre> <p>Get cache statistics.</p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Statistics dictionary.</p> <code></code> get_entry_info Link Python<pre><code>get_entry_info(\n    key: str,\n) -&gt; typing.Optional[typing.Dict[str, typing.Any]]\n</code></pre> <p>Get detailed information about a cache entry.</p> PARAMETER DESCRIPTION <code>key</code> <p>Cache key.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any] or None</code> <p>Entry information or None if not found.</p> <code></code> close Link Python<pre><code>close() -&gt; None\n</code></pre> <p>Close the cache manager and perform final cleanup.</p>"},{"location":"sierra/internal/errors/","title":"Errors","text":""},{"location":"sierra/internal/errors/#error-definitions","title":"Error Definitions","text":"<p>The <code>sierra.internal.errors</code> module defines all custom exception types used throughout sierra-dev, enabling precise error handling and logging.</p> Common Sierra errors Python<pre><code>import sierra.internal.errors as errors\n\ntry:\n    # Simulate a missing scripts directory\n    raise errors.SierraClientPathError(\"Invalid path: ./scripts\")\nexcept errors.SierraClientPathError as e:\n    print(f\"Caught client path error: {e}\")\n\ntry:\n    # Simulate a module load failure\n    raise errors.SierraClientLoadError(\"No invoker found in module\")\nexcept errors.SierraClientLoadError as e:\n    print(f\"Caught load error: {e}\")\n\ntry:\n    # Simulate a runtime failure in an invoker\n    raise errors.SierraExecutionError(\"Script runtime exception\")\nexcept errors.SierraExecutionError as e:\n    print(f\"Caught execution error: {e}\")\n</code></pre>"},{"location":"sierra/internal/errors/#sierra.internal.errors","title":"sierra.internal.errors","text":""},{"location":"sierra/internal/errors/#sierra.internal.errors-classes","title":"Classes","text":""},{"location":"sierra/internal/errors/#sierra.internal.errors.BaseSierraError","title":"BaseSierraError","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all Sierra errors.</p>"},{"location":"sierra/internal/errors/#sierra.internal.errors.SierraPathError","title":"SierraPathError","text":"<p>               Bases: <code>BaseSierraError</code></p> <p>Raised when there is a problem with a filesystem path.</p>"},{"location":"sierra/internal/errors/#sierra.internal.errors.SierraPathNotFoundError","title":"SierraPathNotFoundError","text":"<p>               Bases: <code>SierraPathError</code></p> <p>Raised when a required filesystem path does not exist.</p>"},{"location":"sierra/internal/errors/#sierra.internal.errors.SierraClientPathError","title":"SierraClientPathError","text":"<p>               Bases: <code>SierraPathError</code></p> <p>Raised when the SierraDevelopmentClient cannot load invokers because its <code>environment.script_path</code> (or a given file) is not found or is not a valid <code>.py</code> file.</p>"},{"location":"sierra/internal/errors/#sierra.internal.errors.SierraExecutionError","title":"SierraExecutionError","text":"<p>               Bases: <code>BaseSierraError</code></p> <p>Raised when an execution error occurs in Sierra.</p>"},{"location":"sierra/internal/errors/#sierra.internal.errors.SierraClientLoadError","title":"SierraClientLoadError","text":"<p>               Bases: <code>BaseSierraError</code></p> <p>Raised when a dynamically-imported module contains no valid InvokerScript subclasses.</p>"},{"location":"sierra/internal/errors/#sierra.internal.errors.SierraHTTPError","title":"SierraHTTPError","text":"<p>               Bases: <code>BaseSierraError</code></p> <p>Raised when an HTTP request via Sierra's http client fails.</p>"},{"location":"sierra/internal/errors/#sierra.internal.errors.SierraCacheError","title":"SierraCacheError","text":"<p>               Bases: <code>BaseSierraError</code></p> <p>Raised when a cache-related error occurs in Sierra.</p>"},{"location":"sierra/internal/logger/","title":"Logger","text":""},{"location":"sierra/internal/logger/#logger","title":"Logger","text":"<p>The <code>sierra.internal.logger</code> module provides the <code>UniversalLogger</code> class for structured, leveled logging throughout Sierra\u2011SDK.</p> Using UniversalLogger Python<pre><code>from sierra.internal.logger import UniversalLogger, LogLevel\n\n# Create a logger that writes DEBUG+ messages\nlogger = UniversalLogger(name=\"Sierra\", level=LogLevel.DEBUG)\n\n# Log messages at various levels\nlogger.log(\"Starting application\", \"info\")\nlogger.log(\"Detailed debug info\", \"debug\")\nlogger.log(\"A warning occurred\", \"warning\")\nlogger.log(\"An error occurred\", \"error\")\n</code></pre>"},{"location":"sierra/internal/logger/#sierra.internal.logger","title":"sierra.internal.logger","text":""},{"location":"sierra/internal/logger/#sierra.internal.logger-attributes","title":"Attributes","text":""},{"location":"sierra/internal/logger/#sierra.internal.logger.LogTypeLiteral","title":"LogTypeLiteral  <code>module-attribute</code>","text":"Python<pre><code>LogTypeLiteral = typing.Literal[\n    \"info\", \"warning\", \"debug\", \"error\"\n]\n</code></pre>"},{"location":"sierra/internal/logger/#sierra.internal.logger-classes","title":"Classes","text":""},{"location":"sierra/internal/logger/#sierra.internal.logger.LogLevel","title":"LogLevel","text":"<p>               Bases: <code>str</code>, <code>enum.Enum</code></p> <p>Logging verbosity levels.</p> ATTRIBUTE DESCRIPTION <code>NO_ERROR</code> <p>Suppress all messages.</p> <p> TYPE: <code>str</code> </p> <code>BASIC</code> <p>Log \"info\" and \"warning\".</p> <p> TYPE: <code>str</code> </p> <code>STANDARD</code> <p>Log \"info\", \"warning\", and \"error\".</p> <p> TYPE: <code>str</code> </p> <code>DEBUG</code> <p>Log all levels including \"debug\".</p> <p> TYPE: <code>str</code> </p>"},{"location":"sierra/internal/logger/#sierra.internal.logger.LogLevel-attributes","title":"Attributes","text":"NO_ERROR <code>class-attribute</code> <code>instance-attribute</code> Link Python<pre><code>NO_ERROR = 'no-error'\n</code></pre> <code></code> BASIC <code>class-attribute</code> <code>instance-attribute</code> Link Python<pre><code>BASIC = 'basic'\n</code></pre> <code></code> STANDARD <code>class-attribute</code> <code>instance-attribute</code> Link Python<pre><code>STANDARD = 'standard'\n</code></pre> <code></code> DEBUG <code>class-attribute</code> <code>instance-attribute</code> Link Python<pre><code>DEBUG = 'debug'\n</code></pre>"},{"location":"sierra/internal/logger/#sierra.internal.logger.LogType","title":"LogType","text":"<p>               Bases: <code>str</code>, <code>enum.Enum</code></p> <p>Types of log messages.</p> ATTRIBUTE DESCRIPTION <code>INFO</code> <p>Informational messages.</p> <p> TYPE: <code>str</code> </p> <code>WARNING</code> <p>Warning messages.</p> <p> TYPE: <code>str</code> </p> <code>DEBUG</code> <p>Debug messages.</p> <p> TYPE: <code>str</code> </p> <code>ERROR</code> <p>Error messages.</p> <p> TYPE: <code>str</code> </p>"},{"location":"sierra/internal/logger/#sierra.internal.logger.LogType-attributes","title":"Attributes","text":"INFO <code>class-attribute</code> <code>instance-attribute</code> Link Python<pre><code>INFO = 'info'\n</code></pre> <code></code> WARNING <code>class-attribute</code> <code>instance-attribute</code> Link Python<pre><code>WARNING = 'warning'\n</code></pre> <code></code> DEBUG <code>class-attribute</code> <code>instance-attribute</code> Link Python<pre><code>DEBUG = 'debug'\n</code></pre> <code></code> ERROR <code>class-attribute</code> <code>instance-attribute</code> Link Python<pre><code>ERROR = 'error'\n</code></pre>"},{"location":"sierra/internal/logger/#sierra.internal.logger.LoggerConfig","title":"LoggerConfig","text":"<p>               Bases: <code>typing.TypedDict</code></p> <p>Configuration for UniversalLogger.</p> Keys <p>name : str     Prefix for each log message. (required) level : LogLevel     Minimum log level to emit. (default LogLevel.BASIC) log_file : pathlib.Path | str | None     File path for persistent logging. (default None) clean_logs : bool     If True, uses stdout.write for performance. (default True) enable_colors : bool     If True, ANSI colors are applied. (default True) timestamp_format : str     Format specifier for datetime. (default \"%Y-%m-%d %H:%M:%S\") buffer_size : int     Max messages retained in buffer. (default 1000) auto_flush : bool     Flush buffer when full. (default True)</p>"},{"location":"sierra/internal/logger/#sierra.internal.logger.LoggerConfig-attributes","title":"Attributes","text":"name <code>instance-attribute</code> Link Python<pre><code>name: str\n</code></pre> <code></code> level <code>instance-attribute</code> Link Python<pre><code>level: LogLevel\n</code></pre> <code></code> log_file <code>instance-attribute</code> Link Python<pre><code>log_file: typing.Union[str, pathlib.Path, None]\n</code></pre> <code></code> clean_logs <code>instance-attribute</code> Link Python<pre><code>clean_logs: bool\n</code></pre> <code></code> enable_colors <code>instance-attribute</code> Link Python<pre><code>enable_colors: bool\n</code></pre> <code></code> timestamp_format <code>instance-attribute</code> Link Python<pre><code>timestamp_format: str\n</code></pre> <code></code> buffer_size <code>instance-attribute</code> Link Python<pre><code>buffer_size: int\n</code></pre> <code></code> auto_flush <code>instance-attribute</code> Link Python<pre><code>auto_flush: bool\n</code></pre>"},{"location":"sierra/internal/logger/#sierra.internal.logger.LogColor","title":"LogColor  <code>dataclass</code>","text":"Python<pre><code>LogColor(\n    INFO: str = colorama.Fore.GREEN,\n    WARNING: str = colorama.Fore.YELLOW,\n    DEBUG: str = colorama.Fore.LIGHTBLACK_EX,\n    ERROR: str = colorama.Fore.RED,\n    TIMESTAMP: str = colorama.Fore.CYAN,\n    RESET: str = colorama.Fore.RESET,\n)\n</code></pre> <p>ANSI color codes for log message components.</p>"},{"location":"sierra/internal/logger/#sierra.internal.logger.LogColor-attributes","title":"Attributes","text":"INFO <code>class-attribute</code> <code>instance-attribute</code> Link Python<pre><code>INFO: str = colorama.Fore.GREEN\n</code></pre> <code></code> WARNING <code>class-attribute</code> <code>instance-attribute</code> Link Python<pre><code>WARNING: str = colorama.Fore.YELLOW\n</code></pre> <code></code> DEBUG <code>class-attribute</code> <code>instance-attribute</code> Link Python<pre><code>DEBUG: str = colorama.Fore.LIGHTBLACK_EX\n</code></pre> <code></code> ERROR <code>class-attribute</code> <code>instance-attribute</code> Link Python<pre><code>ERROR: str = colorama.Fore.RED\n</code></pre> <code></code> TIMESTAMP <code>class-attribute</code> <code>instance-attribute</code> Link Python<pre><code>TIMESTAMP: str = colorama.Fore.CYAN\n</code></pre> <code></code> RESET <code>class-attribute</code> <code>instance-attribute</code> Link Python<pre><code>RESET: str = colorama.Fore.RESET\n</code></pre>"},{"location":"sierra/internal/logger/#sierra.internal.logger.LogBuffer","title":"LogBuffer","text":"Python<pre><code>LogBuffer(max_size: int = 1000)\n</code></pre> <p>In-memory FIFO buffer for log entries.</p> PARAMETER DESCRIPTION <code>max_size</code> <p>Maximum entries to retain.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p>"},{"location":"sierra/internal/logger/#sierra.internal.logger.LogBuffer-attributes","title":"Attributes","text":"messages <code>instance-attribute</code> Link Python<pre><code>messages: list[str] = []\n</code></pre> <code></code> max_size <code>instance-attribute</code> Link Python<pre><code>max_size: int = max_size\n</code></pre>"},{"location":"sierra/internal/logger/#sierra.internal.logger.LogBuffer-functions","title":"Functions","text":"add Link Python<pre><code>add(message: str) -&gt; None\n</code></pre> <p>Add a log entry to the buffer.</p> PARAMETER DESCRIPTION <code>message</code> <p>Formatted log message.</p> <p> TYPE: <code>str</code> </p> <code></code> flush Link Python<pre><code>flush() -&gt; list[str]\n</code></pre> <p>Clear buffer and return all entries.</p> RETURNS DESCRIPTION <code>list[str]</code> <p>All buffered messages before clearing.</p> <code></code> get_all Link Python<pre><code>get_all() -&gt; list[str]\n</code></pre> <p>Retrieve buffer contents without clearing.</p> RETURNS DESCRIPTION <code>list[str]</code> <p>Current buffered messages.</p>"},{"location":"sierra/internal/logger/#sierra.internal.logger.UniversalLogger","title":"UniversalLogger","text":"Python<pre><code>UniversalLogger(**kwargs: typing.Unpack[LoggerConfig])\n</code></pre> <p>Main logger class integrating console, file, and buffer outputs.</p> PARAMETER DESCRIPTION <code>**config</code> <p>Configuration options unpacked via typing.Unpack[LoggerConfig].</p> <p> TYPE: <code>LoggerConfig</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If 'name' is missing or empty.</p> <code>OSError</code> <p>If log file directory or file cannot be created.</p>"},{"location":"sierra/internal/logger/#sierra.internal.logger.UniversalLogger-attributes","title":"Attributes","text":"name <code>instance-attribute</code> Link Python<pre><code>name: str = name\n</code></pre> <code></code> level <code>instance-attribute</code> Link Python<pre><code>level: LogLevel = kwargs.get('level', LogLevel.BASIC)\n</code></pre> <code></code> log_file_path <code>instance-attribute</code> Link Python<pre><code>log_file_path: typing.Optional[pathlib.Path] = (\n    pathlib.Path(raw_log_file) if raw_log_file else None\n)\n</code></pre> <code></code> clean_logs <code>instance-attribute</code> Link Python<pre><code>clean_logs: bool = kwargs.get('clean_logs', True)\n</code></pre> <code></code> enable_colors <code>instance-attribute</code> Link Python<pre><code>enable_colors: bool = kwargs.get('enable_colors', True)\n</code></pre> <code></code> timestamp_format <code>instance-attribute</code> Link Python<pre><code>timestamp_format: str = kwargs.get(\n    \"timestamp_format\", \"%Y-%m-%d %H:%M:%S\"\n)\n</code></pre> <code></code> buffer_size <code>instance-attribute</code> Link Python<pre><code>buffer_size: int = kwargs.get('buffer_size', 1000)\n</code></pre> <code></code> auto_flush <code>instance-attribute</code> Link Python<pre><code>auto_flush: bool = kwargs.get('auto_flush', True)\n</code></pre> <code></code> colors <code>instance-attribute</code> Link Python<pre><code>colors: LogColor = LogColor()\n</code></pre> <code></code> buffer <code>instance-attribute</code> Link Python<pre><code>buffer: LogBuffer = LogBuffer(self.buffer_size)\n</code></pre>"},{"location":"sierra/internal/logger/#sierra.internal.logger.UniversalLogger-functions","title":"Functions","text":"log Link Python<pre><code>log(message: str, log_type: LogTypeLiteral) -&gt; None\n</code></pre> <p>Emit a log entry.</p> PARAMETER DESCRIPTION <code>message</code> <p>Content of the log.</p> <p> TYPE: <code>str</code> </p> <code>log_type</code> <p>Severity level.</p> <p> TYPE: <code>Literal[info, warning, debug, error]</code> </p> <code></code> flush_buffer Link Python<pre><code>flush_buffer() -&gt; list[str]\n</code></pre> <p>Flush and retrieve buffered messages.</p> RETURNS DESCRIPTION <code>list[str]</code> <p>All buffered lines before flush.</p> <code></code> get_logs Link Python<pre><code>get_logs() -&gt; list[str]\n</code></pre> <p>Get buffered messages without flushing.</p> RETURNS DESCRIPTION <code>list[str]</code> <p>Current buffer contents.</p> <code></code> clear_console <code>staticmethod</code> Link Python<pre><code>clear_console() -&gt; None\n</code></pre> <p>Clear the terminal screen.</p>"}]}